class name;;Method name;;number of detected pattern;;method Declaration;;parameter;;number of occurrences;;occurrenceType;;unitOnwhichOccurrenceIsDetected;;commentFragment
java.util.WeakHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;hash;;1;;int hash(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i3 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;removeMapping;;1;;boolean removeMapping(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = interfaceinvoke r3.<java.util.Map$Entry: java.lang.Object getKey()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
java.util.AbstractMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.AbstractCollection;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;fill;;1;;public static void fill(long[], long)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = l0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(long[], int, int, long)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = l2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(int[], int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = i0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(int[], int, int, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = i2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(short[], short)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = s0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(short[], int, int, short)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = s2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(char[], char)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = c0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(char[], int, int, char)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = c2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(byte[], byte)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = b0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(byte[], int, int, byte)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = b2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(boolean[], boolean)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = z0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(boolean[], int, int, boolean)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = z0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(double[], double)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(double[], int, int, double)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(float[], float)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(float[], int, int, float)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(java.lang.Object[], java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = r1;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(java.lang.Object[], int, int, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = r1;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;copyOf;;1;;public static java.lang.Object[] copyOf(java.lang.Object[], int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOf;;1;;public static java.lang.Object[] copyOf(java.lang.Object[], int, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Class: java.lang.Class getComponentType()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOfRange;;1;;public static java.lang.Object[] copyOfRange(java.lang.Object[], int, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOfRange;;1;;public static java.lang.Object[] copyOfRange(java.lang.Object[], int, int, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r11 = virtualinvoke r1.<java.lang.Class: java.lang.Class getComponentType()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;deepEquals0;;1;;static boolean deepEquals0(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;z1 = virtualinvoke r0.<java.lang.Object: boolean equals(java.lang.Object)>(r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Locale;;getDefault;;1;;public static java.util.Locale getDefault(java.util.Locale$Category)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r0.<java.util.Locale$Category: int ordinal()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Locale;;setDefault;;2;;public static synchronized void setDefault(java.util.Locale$Category, java.util.Locale)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Locale;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;r2 = $r3.<java.util.Locale: sun.util.locale.BaseLocale baseLocale>;;pattern detected param  r1 must not be null it define a local $r3which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = $r6.<java.util.Locale: sun.util.locale.LocaleExtensions localeExtensions>;;pattern detected param  r1 must not be null it define a local $r6which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r10 = $r9.<java.util.Locale: sun.util.locale.LocaleExtensions localeExtensions>;;pattern detected param  r1 must not be null it define a local $r9which used in  FieldRef 
java.util.AbstractList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractList;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r3 = interfaceinvoke $r6.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null it define a local $r6which used in  InvokeExpr 
java.util.AbstractSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.AbstractSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z4 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractQueue;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.AbstractSequentialList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayDeque;;addFirst;;1;;public void addFirst(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.ArrayDeque;;addLast;;1;;public void addLast(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.ArrayDeque;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.Properties;;loadFromXML;;1;;public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;storeToXML;;1;;public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;storeToXML;;1;;public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;list;;1;;public void list(java.io.PrintStream)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintStream: void println(java.lang.String)>("-- listing properties --");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintStream: void println(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Properties;;list;;1;;public void list(java.io.PrintWriter)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintWriter: void println(java.lang.String)>("-- listing properties --");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintWriter: void println(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;hash;;1;;final int hash(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;transfer;;1;;void transfer(java.util.HashMap$Entry[], boolean)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r8 = r1[i3];;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i3] = r3;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.HashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;removeMapping;;1;;final java.util.HashMap$Entry removeMapping(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r3 = interfaceinvoke r2.<java.util.Map$Entry: java.lang.Object getKey()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.Hashtable;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Hashtable;;contains;;1;;public synchronized boolean contains(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Hashtable;;put;;1;;public synchronized java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.Hashtable;;putAll;;1;;public synchronized void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Hashtable;;equals;;1;;public synchronized boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.ArrayList;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.ArrayList;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(int[], int, int)
*;; * ;; * ;;*;;r0;;23
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i13 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i15 = r0[$i14];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i17 = r0[$i16];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i18 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i19 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i21 = r0[$i20];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i23 = r0[$i22];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i24 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;i6 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i26 = r0[i5];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i4] = $i26;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i5] = i6;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i29 = r0[$i28];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i30 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;$i39 = r2[i38];;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i46 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i47 = r0[i11];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i49 = r0[$i48];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $i49;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i51 = r0[$i50];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $i51;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i56 = r0[i53];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i53] = $i56;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(long[], int, int)
*;; * ;; * ;;*;;r0;;23
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l13 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l15 = r0[$i14];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l18 = r0[$i17];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l19 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l21 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l23 = r0[$i22];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l26 = r0[$i25];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l27 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;l6 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l30 = r0[i5];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i4] = $l30;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i5] = l6;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l33 = r0[$i32];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l34 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;$l44 = r2[i43];;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l51 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l52 = r0[i11];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l55 = r0[$i54];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $l55;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l57 = r0[$i56];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $l57;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l62 = r0[i59];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i59] = $l62;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(short[], int, int)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$s7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = s4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(char[], int, int)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$c7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = c4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(byte[], int, int)
*;; * ;; * ;;*;;r0;;7
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = b4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;b17 = r0[$i16];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b18 = r0[i15];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b20 = r0[i15];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[$i19] = $b20;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[$i22] = b17;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(float[], int, int)
*;; * ;; * ;;*;;r0;;10
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f3 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f0 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f4 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = $f4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f1 = r0[i6];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f5 = r0[i0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f2 = r0[i9];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i9] = 0.0F;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i10] = -0.0F;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(double[], int, int)
*;; * ;; * ;;*;;r0;;10
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d3 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d0 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d4 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = $d4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d1 = r0[i6];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d5 = r0[i0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d2 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i10] = 0.0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i11] = -0.0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.HashSet;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Random;;nextBytes;;1;;public void nextBytes(byte[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = $b7;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(long[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l2 = r0[$i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(java.nio.LongBuffer)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r0.<java.nio.LongBuffer: java.nio.LongBuffer slice()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(java.nio.ByteBuffer)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.nio.ByteBuffer: java.nio.ByteBuffer slice()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.BitSet;;intersects;;1;;public boolean intersects(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;and;;1;;public void and(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r5 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;or;;1;;public void or(java.util.BitSet)
*;; * ;; * ;;*;;r1;;7
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i6 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i7 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i12 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;xor;;1;;public void xor(java.util.BitSet)
*;; * ;; * ;;*;;r1;;8
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i6 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i7 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i12 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i13 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;andNot;;1;;public void andNot(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;specialinvoke r2.<java.util.BitSet: void checkInvariants()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i2 = r2.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.Calendar;;setTime;;1;;public final void setTime(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Calendar;;checkDisplayNameParams;;1;;boolean checkDisplayNameParams(int, int, int, int, java.util.Locale, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Calendar;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$z1 = r2.<java.util.Calendar: boolean lenient>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.Calendar: int firstDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i5 = r2.<java.util.Calendar: int minimalDaysInFirstWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.Calendar: java.util.TimeZone zone>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.TimeZone;;setID;;1;;public void setID(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Date;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$l1 = virtualinvoke $r2.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.Date;;getMillisOf;;1;;static final long getMillisOf(java.util.Date)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r0.<java.util.Date: long fastTime>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
java.util.ResourceBundle;;getBundle;;1;;public static java.util.ResourceBundle getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.ResourceBundle;;clearCache;;1;;public static final void clearCache(java.lang.ClassLoader)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.ResourceBundle;;containsKey;;1;;public boolean containsKey(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;get;;1;;public java.lang.Object get(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;containsKey;;1;;public boolean containsKey(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;containsValue;;1;;public boolean containsValue(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r8;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;putIfAbsent;;1;;public java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;replace;;1;;public java.lang.Object replace(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.GregorianCalendar;;setGregorianChange;;1;;public void setGregorianChange(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.GregorianCalendar;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l1 = $r2.<java.util.GregorianCalendar: long gregorianCutover>;;pattern detected param  r1 must not be null it define a local $r2which used in  FieldRef 
java.util.SimpleTimeZone;;inDaylightTime;;1;;public boolean inDaylightTime(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.SimpleTimeZone;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.SimpleTimeZone: java.lang.String getID()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.SimpleTimeZone;;hasSameRules;;1;;public boolean hasSameRules(java.util.TimeZone)
*;; * ;; * ;;*;;r1;;16
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.SimpleTimeZone: int rawOffset>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$z2 = r2.<java.util.SimpleTimeZone: boolean useDaylight>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.SimpleTimeZone: int dstSavings>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i5 = r2.<java.util.SimpleTimeZone: int startMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i7 = r2.<java.util.SimpleTimeZone: int startMonth>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i9 = r2.<java.util.SimpleTimeZone: int startDay>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i11 = r2.<java.util.SimpleTimeZone: int startDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i13 = r2.<java.util.SimpleTimeZone: int startTime>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i15 = r2.<java.util.SimpleTimeZone: int startTimeMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i17 = r2.<java.util.SimpleTimeZone: int endMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i19 = r2.<java.util.SimpleTimeZone: int endMonth>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i21 = r2.<java.util.SimpleTimeZone: int endDay>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i23 = r2.<java.util.SimpleTimeZone: int endDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i25 = r2.<java.util.SimpleTimeZone: int endTime>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i27 = r2.<java.util.SimpleTimeZone: int endTimeMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i29 = r2.<java.util.SimpleTimeZone: int startYear>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.concurrent.locks.ReentrantLock;;tryLock;;1;;public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.ReentrantLock;;hasWaiters;;1;;public boolean hasWaiters(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantLock;;getWaitQueueLength;;1;;public int getWaitQueueLength(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantLock;;getWaitingThreads;;1;;protected java.util.Collection getWaitingThreads(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Collections;;sort;;1;;public static void sort(java.util.List)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;sort;;1;;public static void sort(java.util.List, java.util.Comparator)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;binarySearch;;1;;public static int binarySearch(java.util.List, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;binarySearch;;1;;public static int binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;reverse;;1;;public static void reverse(java.util.List)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator(int)>(i0);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;shuffle;;2;;public static void shuffle(java.util.List, java.util.Random)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.util.Random: int nextInt(int)>(i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i7 = virtualinvoke r1.<java.util.Random: int nextInt(int)>(i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;swap;;1;;public static void swap(java.util.List, int, int)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i0);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = interfaceinvoke r1.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, $r2);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;interfaceinvoke r1.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i0, $r3);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
java.util.Collections;;fill;;1;;public static void fill(java.util.List, java.lang.Object)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;copy;;2;;public static void copy(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, $r4);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r6 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;min;;1;;public static java.lang.Object min(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;min;;1;;public static java.lang.Object min(java.util.Collection, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;max;;1;;public static java.lang.Object max(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;max;;1;;public static java.lang.Object max(java.util.Collection, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;rotate;;1;;public static void rotate(java.util.List, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;replaceAll;;1;;public static boolean replaceAll(java.util.List, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r0;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i3);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i3, r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r7 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;indexOfSubList;;2;;public static int indexOfSubList(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r5 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;lastIndexOfSubList;;2;;public static int lastIndexOfSubList(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator(int)>(i2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r5 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;list;;1;;public static java.util.ArrayList list(java.util.Enumeration)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r0.<java.util.Enumeration: boolean hasMoreElements()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.Enumeration: java.lang.Object nextElement()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;frequency;;1;;public static int frequency(java.util.Collection, java.lang.Object)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;disjoint;;2;;public static boolean disjoint(java.util.Collection, java.util.Collection)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.Collection: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z3 = interfaceinvoke r2.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r0 must not be null it define a local r2which used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r4 = interfaceinvoke r3.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
java.util.Collections;;addAll;;2;;public static transient boolean addAll(java.util.Collection, java.lang.Object[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.Collection: boolean add(java.lang.Object)>(r3);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r3 = r2[i1];;pattern detected param  r1 must not be null it define a local r2which used in  ArrayRef 
java.util.Currency;;getInstance;;1;;public static java.util.Currency getInstance(java.util.Locale)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = virtualinvoke r0.<java.util.Locale: java.lang.String getCountry()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Pattern;;split;;1;;public java.lang.String[] split(java.lang.CharSequence, int)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i7 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i7);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r11 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.String toString()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i9 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r12 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i9);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.Pattern;;quote;;1;;public static java.lang.String quote(java.lang.String)
*;; * ;; * ;;*;;r0;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r0.<java.lang.String: int indexOf(java.lang.String)>("\\E");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r0.<java.lang.String: int indexOf(java.lang.String,int)>("\\E", i1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r0.<java.lang.String: java.lang.String substring(int,int)>(i1, i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r12 = virtualinvoke r0.<java.lang.String: java.lang.String substring(int,int)>(i1, $i6);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;<init>;;1;;void <init>(java.util.regex.Pattern, java.lang.CharSequence)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i1 = r1.<java.util.regex.Pattern: int capturingGroupCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.regex.Pattern: int localCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.regex.Matcher;;usePattern;;1;;public java.util.regex.Matcher usePattern(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.regex.Matcher;;group;;1;;public java.lang.String group(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.regex.Matcher;;quoteReplacement;;1;;public static java.lang.String quoteReplacement(java.lang.String)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r0.<java.lang.String: int indexOf(int)>(92);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = virtualinvoke r0.<java.lang.String: int indexOf(int)>(36);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c1 = virtualinvoke r0.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;appendReplacement;;2;;public java.util.regex.Matcher appendReplacement(java.lang.StringBuffer, java.lang.String)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence,int,int)>($r35, $i24, $i25);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;8
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c1 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c7 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i6);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c9 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i8);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i11 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c9 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i10);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i15 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c16 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;appendTail;;1;;public java.lang.StringBuffer appendTail(java.lang.StringBuffer)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence,int,int)>($r2, $i0, $i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;replaceFirst;;1;;public java.lang.String replaceFirst(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.StringTokenizer;;<init>;;1;;public void <init>(java.lang.String, java.lang.String, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.DuplicateFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.EnumMap;;<init>;;1;;public void <init>(java.util.EnumMap)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.EnumMap: java.lang.Enum[] keyUniverse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.EnumMap: int size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.EnumMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.EnumMap: java.lang.Enum[] keyUniverse>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i0 = r2.<java.util.EnumMap: int size>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r1.<java.util.Map: boolean isEmpty()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = interfaceinvoke r1.<java.util.Map: java.util.Set keySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.EnumMap;;containsKey;;1;;public boolean containsKey(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;get;;1;;public java.lang.Object get(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;put;;1;;public java.lang.Object put(java.lang.Enum, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.EnumMap;;remove;;1;;public java.lang.Object remove(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z1 = virtualinvoke r2.<java.util.EnumMap: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r8 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r15 = r2.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.EnumMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i2 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r12 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z3 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r13 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.EnumSet;;copyOf;;1;;public static java.util.EnumSet copyOf(java.util.EnumSet)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.util.EnumSet: java.util.EnumSet clone()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;copyOf;;1;;public static java.util.EnumSet copyOf(java.util.Collection)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r5 = virtualinvoke $r4.<java.util.EnumSet: java.util.EnumSet clone()>();;pattern detected param  r0 must not be null it define a local $r4which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.Collection: boolean isEmpty()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;2;;public static transient java.util.EnumSet of(java.lang.Enum, java.lang.Enum[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r4 = r3[i1];;pattern detected param  r1 must not be null it define a local r3which used in  ArrayRef 
java.util.EnumSet;;range;;1;;public static java.util.EnumSet range(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r0.<java.lang.Enum: int compareTo(java.lang.Enum)>(r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;typeCheck;;1;;final void typeCheck(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;addRange;;2;;void addRange(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r1;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i10 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i12 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i18 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i14 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i17 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;add;;1;;public boolean add(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.JumboEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r6 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.JumboEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r15 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.JumboEnumSet: int size>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;addRange;;2;;void addRange(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.RegularEnumSet;;add;;1;;public boolean add(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.RegularEnumSet;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.RegularEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l0 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.RegularEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l4 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l4 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.EventObject;;<init>;;1;;public void <init>(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.FormatFlagsConversionMismatchException;;<init>;;1;;public void <init>(java.lang.String, char)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Objects;;compare;;1;;public static int compare(java.lang.Object, java.lang.Object, java.util.Comparator)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r2.<java.util.Comparator: int compare(java.lang.Object,java.lang.Object)>(r0, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Objects;;requireNonNull;;1;;public static java.lang.Object requireNonNull(java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.Objects;;requireNonNull;;1;;public static java.lang.Object requireNonNull(java.lang.Object, java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.MissingFormatArgumentException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.UnknownFormatConversionException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.LinkedHashMap;;transfer;;1;;void transfer(java.util.HashMap$Entry[], boolean)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r8 = r1[i1];;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i1] = r2;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.LinkedHashSet;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i1 = virtualinvoke r2.<java.util.IdentityHashMap: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;r3 = r2.<java.util.IdentityHashMap: java.lang.Object[] table>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = interfaceinvoke r6.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null it define a local r6which used in  InvokeExpr 
java.util.IllegalFormatConversionException;;<init>;;1;;public void <init>(char, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.IllegalFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.LinkedList;;linkBefore;;1;;void linkBefore(java.lang.Object, java.util.LinkedList$Node)
*;; * ;; * ;;*;;r2;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r2.<java.util.LinkedList$Node: java.util.LinkedList$Node prev>;;pattern detected param  r2 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2.<java.util.LinkedList$Node: java.util.LinkedList$Node prev> = r4;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.LinkedList;;unlink;;1;;java.lang.Object unlink(java.util.LinkedList$Node)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.LinkedList$Node: java.lang.Object item>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.LinkedList$Node: java.util.LinkedList$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r4 = r1.<java.util.LinkedList$Node: java.util.LinkedList$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.util.LinkedList$Node prev> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.util.LinkedList$Node next> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.LinkedList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.LinkedList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[$i4] = $r8;;pattern detected param  r1 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i7] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.ListResourceBundle;;handleGetObject;;1;;public final java.lang.Object handleGetObject(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.PropertyPermission;;implies;;1;;public boolean implies(java.security.Permission)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.PropertyPermission;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.PropertyPermission: java.lang.String getName()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.MissingFormatWidthException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Observable;;addObserver;;1;;public synchronized void addObserver(java.util.Observer)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Vector;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Vector;;toArray;;1;;public synchronized java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.Vector;;addAll;;1;;public synchronized boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Vector;;addAll;;1;;public synchronized boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = interfaceinvoke r2.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r5 = virtualinvoke r4.<java.util.PriorityQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r4which used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.PriorityQueue)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.PriorityQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.PriorityQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.XMLUtils;;importProperties;;2;;static void importProperties(java.util.Properties, org.w3c.dom.Element)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.util.Properties: java.lang.Object setProperty(java.lang.String,java.lang.String)>($r10, r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<org.w3c.dom.Element: org.w3c.dom.NodeList getChildNodes()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.XMLUtils;;save;;1;;static void save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r0;;5
*;;*;;*;;*;;*;;*;;monitorStmt for param;;entermonitor r0;;pattern detected param  r0 must not be null  because used in  monitorStmt 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r24 = virtualinvoke r0.<java.util.Properties: java.util.Set stringPropertyNames()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r28 = virtualinvoke r0.<java.util.Properties: java.lang.String getProperty(java.lang.String)>(r10);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;monitorStmt for local initialized from param;;exitmonitor r23;;pattern detected param  r0 must not be null it define a local r23which used in  monitorStmt 
*;;*;;*;;*;;*;;*;;monitorStmt for local initialized from param;;exitmonitor r23;;pattern detected param  r0 must not be null it define a local r23which used in  monitorStmt 
java.util.PropertyResourceBundle;;handleGetObject;;1;;public java.lang.Object handleGetObject(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;useLocale;;1;;public java.util.Scanner useLocale(java.util.Locale)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.util.Locale: boolean equals(java.lang.Object)>($r4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Scanner;;hasNext;;1;;public boolean hasNext(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;next;;1;;public java.lang.String next(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;findInLine;;1;;public java.lang.String findInLine(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;findWithinHorizon;;1;;public java.lang.String findWithinHorizon(java.util.regex.Pattern, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;skip;;1;;public java.util.Scanner skip(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Timer;;schedule;;1;;public void schedule(java.util.TimerTask, java.util.Date)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Timer;;schedule;;1;;public void schedule(java.util.TimerTask, java.util.Date, long)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Timer;;scheduleAtFixedRate;;1;;public void scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;<init>;;1;;public void <init>(java.util.SortedMap)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r1.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.SortedMap: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.SortedMap: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r2 = interfaceinvoke $r4.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;getEntry;;1;;final java.util.TreeMap$Entry getEntry(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r11;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;compare;;1;;final int compare(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke $r4.<java.lang.Comparable: int compareTo(java.lang.Object)>(r2);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.TreeMap;;key;;1;;static java.lang.Object key(java.util.TreeMap$Entry)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;addAllForTreeSet;;1;;void addAllForTreeSet(java.util.SortedSet, java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.SortedSet: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.SortedSet: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeSet;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r4 = interfaceinvoke r2.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.UnknownFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.UUID;;fromString;;1;;public static java.util.UUID fromString(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = virtualinvoke r0.<java.lang.String: java.lang.String[] split(java.lang.String)>("-");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.UUID;;compareTo;;1;;public int compareTo(java.util.UUID)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.UUID: long mostSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l5 = r1.<java.util.UUID: long mostSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l8 = r1.<java.util.UUID: long leastSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l11 = r1.<java.util.UUID: long leastSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;invokeAny;;1;;public java.lang.Object invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.AbstractExecutorService;;invokeAll;;1;;public java.util.List invokeAll(java.util.Collection) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r9;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.TimeUnit;;timedWait;;1;;public void timedWait(java.lang.Object, long) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: void wait(long,int)>(l1, i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.TimeUnit;;timedJoin;;1;;public void timedJoin(java.lang.Thread, long) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Thread: void join(long,int)>(l1, i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.FutureTask;;<init>;;1;;public void <init>(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.FutureTask;;get;;1;;public java.lang.Object get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ExecutorCompletionService;;<init>;;1;;public void <init>(java.util.concurrent.Executor)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ExecutorCompletionService;;submit;;1;;public java.util.concurrent.Future submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ExecutorCompletionService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;acquireQueued;;1;;final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node predecessor()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;isQueued;;1;;public final boolean isQueued(java.lang.Thread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;isOnSyncQueue;;1;;final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;transferForSignal;;1;;final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;fullyRelease;;1;;final int fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;owns;;1;;public final boolean owns(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;hasWaiters;;1;;public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: boolean hasWaiters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;getWaitQueueLength;;1;;public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: int getWaitQueueLength()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;getWaitingThreads;;1;;public final java.util.Collection getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: java.util.Collection getWaitingThreads()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;<init>;;1;;public void <init>(int, boolean, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i3] = $r9;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.ArrayBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>($r8);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>($r8);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;unlink;;1;;void unlink(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: void lazySetPrev(java.util.concurrent.ConcurrentLinkedDeque$Node)>($r21);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: void lazySetNext(java.util.concurrent.ConcurrentLinkedDeque$Node)>($r23);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;succ;;1;;final java.util.concurrent.ConcurrentLinkedDeque$Node succ(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedDeque;;pred;;1;;final java.util.concurrent.ConcurrentLinkedDeque$Node pred(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;removeFirstOccurrence;;1;;public boolean removeFirstOccurrence(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;removeLastOccurrence;;1;;public boolean removeLastOccurrence(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;updateHead;;1;;final void updateHead(java.util.concurrent.ConcurrentLinkedQueue$Node, java.util.concurrent.ConcurrentLinkedQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedQueue$Node: void lazySetNext(java.util.concurrent.ConcurrentLinkedQueue$Node)>(r1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;succ;;1;;final java.util.concurrent.ConcurrentLinkedQueue$Node succ(java.util.concurrent.ConcurrentLinkedQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedQueue$Node: java.util.concurrent.ConcurrentLinkedQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedQueue;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i2] = r3;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.ConcurrentSkipListMap;;compare;;1;;int compare(java.lang.Object, java.lang.Object) throws java.lang.ClassCastException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i1 = interfaceinvoke $r4.<java.lang.Comparable: int compareTo(java.lang.Object)>(r2);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;inHalfOpenRange;;1;;boolean inHalfOpenRange(java.lang.Object, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;inOpenRange;;1;;boolean inOpenRange(java.lang.Object, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;<init>;;1;;public void <init>(java.util.SortedMap)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;containsValue;;1;;public boolean containsValue(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r11 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>($r10);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r12 = interfaceinvoke r2.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;putIfAbsent;;1;;public java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;remove;;1;;public boolean remove(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;replace;;1;;public java.lang.Object replace(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;headMap;;1;;public java.util.concurrent.ConcurrentNavigableMap headMap(java.lang.Object, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;tailMap;;1;;public java.util.concurrent.ConcurrentNavigableMap tailMap(java.lang.Object, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;toList;;1;;static final java.util.List toList(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Collection: boolean containsAll(java.util.Collection)>(r0);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.CopyOnWriteArrayList;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAllAbsent;;1;;public int addAllAbsent(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CountDownLatch;;await;;1;;public boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CyclicBarrier;;await;;1;;public int await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.BrokenBarrierException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.DelayQueue;;poll;;1;;public java.util.concurrent.Delayed poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.DelayQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.DelayQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Exchanger;;exchange;;1;;public java.lang.Object exchange(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.LockSupport;;getBlocker;;1;;public static java.lang.Object getBlocker(java.lang.Thread)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingQueue;;put;;1;;public void put(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;offer;;2;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingQueue;;unlink;;2;;void unlink(java.util.concurrent.LinkedBlockingQueue$Node, java.util.concurrent.LinkedBlockingQueue$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.LinkedBlockingQueue$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.LinkedBlockingQueue$Node: java.util.concurrent.LinkedBlockingQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2.<java.util.concurrent.LinkedBlockingQueue$Node: java.util.concurrent.LinkedBlockingQueue$Node next> = $r3;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i3] = $r10;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i1] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.LinkedBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;unconfigurableExecutorService;;1;;public static java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;unconfigurableScheduledExecutorService;;1;;public static java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.lang.Runnable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.security.PrivilegedAction)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;privilegedCallable;;1;;public static java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;privilegedCallableUsingCurrentClassLoader;;1;;public static java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;runWorker;;1;;final void runWorker(java.util.concurrent.ThreadPoolExecutor$Worker)
*;; * ;; * ;;*;;r1;;10
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Runnable firstTask>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Runnable firstTask> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void lock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r9 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks> = $l1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void unlock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l2 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks> = $l3;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void unlock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;<init>;;1;;public void <init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l5 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;execute;;1;;public void execute(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;awaitTermination;;1;;public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;setThreadFactory;;1;;public void setThreadFactory(java.util.concurrent.ThreadFactory)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;setRejectedExecutionHandler;;1;;public void setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;setKeepAliveTime;;1;;public void setKeepAliveTime(long, java.util.concurrent.TimeUnit)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;getKeepAliveTime;;1;;public long getKeepAliveTime(java.util.concurrent.TimeUnit)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long convert(long,java.util.concurrent.TimeUnit)>($l0, $r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;put;;1;;public void put(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;offer;;2;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean isEmpty()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.SynchronousQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.ScheduledThreadPoolExecutor;;reExecutePeriodic;;1;;void reExecutePeriodic(java.util.concurrent.RunnableScheduledFuture)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.concurrent.RunnableScheduledFuture: boolean cancel(boolean)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;work;;1;;final void work(java.util.concurrent.ForkJoinWorkerThread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$z1 = r1.<java.util.concurrent.ForkJoinWorkerThread: boolean terminate>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinPool;;tryAwaitJoin;;1;;final void tryAwaitJoin(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void tryAwaitDone(long)>(0L);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;timedAwaitJoin;;1;;final void timedAwaitJoin(java.util.concurrent.ForkJoinTask, long)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i4 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i8 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void tryAwaitDone(long)>(l2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i10 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;deregisterWorker;;1;;final void deregisterWorker(java.util.concurrent.ForkJoinWorkerThread, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;i0 = r1.<java.util.concurrent.ForkJoinWorkerThread: int poolIndex>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;i1 = r1.<java.util.concurrent.ForkJoinWorkerThread: int stealCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinPool;;<init>;;1;;public void <init>(int, java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory, java.lang.Thread$UncaughtExceptionHandler, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;invoke;;1;;public java.lang.Object invoke(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;execute;;1;;public void execute(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;execute;;1;;public void execute(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;invokeAll;;1;;public java.util.List invokeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;drainTasksTo;;1;;protected int drainTasksTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;awaitTermination;;1;;public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;managedBlock;;1;;public static void managedBlock(java.util.concurrent.ForkJoinPool$ManagedBlocker) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.concurrent.ForkJoinPool$ManagedBlocker: boolean isReleasable()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r0.<java.util.concurrent.ForkJoinPool$ManagedBlocker: boolean block()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinWorkerThread;;<init>;;1;;protected void <init>(java.util.concurrent.ForkJoinPool)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.ForkJoinPool: java.lang.String nextWorkerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.util.concurrent.ForkJoinPool: int registerWorker(java.util.concurrent.ForkJoinWorkerThread)>(r0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$z0 = r1.<java.util.concurrent.ForkJoinPool: boolean locallyFifo>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ForkJoinPool: java.lang.Thread$UncaughtExceptionHandler ueh>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinWorkerThread;;drainTasksTo;;1;;final int drainTasksTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinWorkerThread;;joinTask;;1;;final int joinTask(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinTask;;invokeAll;;2;;public static void invokeAll(java.util.concurrent.ForkJoinTask, java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.util.concurrent.ForkJoinTask: java.lang.Object invoke()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: java.util.concurrent.ForkJoinTask fork()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: java.lang.Object join()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinTask;;invokeAll;;1;;public static transient void invokeAll(java.util.concurrent.ForkJoinTask[])
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r2 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r5 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.concurrent.ForkJoinTask;;invokeAll;;1;;public static java.util.Collection invokeAll(java.util.Collection)
*;; * ;; * ;;*;;r0;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = interfaceinvoke r0.<java.util.Collection: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = interfaceinvoke r0.<java.util.Collection: java.lang.Object[] toArray(java.lang.Object[])>($r4);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i3 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r7 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
java.util.concurrent.ForkJoinTask;;get;;1;;public final java.lang.Object get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l7 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toMillis(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;unlink;;1;;void unlink(java.util.concurrent.LinkedBlockingDeque$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.util.concurrent.LinkedBlockingDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.util.concurrent.LinkedBlockingDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedBlockingDeque;;offerFirst;;1;;public boolean offerFirst(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerLast;;1;;public boolean offerLast(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;putFirst;;1;;public void putFirst(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;putLast;;1;;public void putLast(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerFirst;;2;;public boolean offerFirst(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerLast;;2;;public boolean offerLast(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;pollFirst;;1;;public java.lang.Object pollFirst(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;pollLast;;1;;public java.lang.Object pollLast(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i4] = $r9;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.LinkedTransferQueue;;succ;;1;;final java.util.concurrent.LinkedTransferQueue$Node succ(java.util.concurrent.LinkedTransferQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedTransferQueue;;unsplice;;1;;final void unsplice(java.util.concurrent.LinkedTransferQueue$Node, java.util.concurrent.LinkedTransferQueue$Node)
*;; * ;; * ;;*;;r2;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<java.util.concurrent.LinkedTransferQueue$Node: void forgetContents()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r2.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r2 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r8 = r2.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedTransferQueue;;tryTransfer;;1;;public boolean tryTransfer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedTransferQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedTransferQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedTransferQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Phaser;;awaitAdvanceInterruptibly;;1;;public int awaitAdvanceInterruptibly(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r6 = interfaceinvoke r3.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = virtualinvoke r7.<java.util.concurrent.PriorityBlockingQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r7which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = virtualinvoke r7.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null it define a local r7which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r10 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.Semaphore;;tryAcquire;;1;;public boolean tryAcquire(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.Semaphore;;tryAcquire;;1;;public boolean tryAcquire(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicIntegerArray;;<init>;;1;;public void <init>(int[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Object clone()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicLongArray;;<init>;;1;;public void <init>(long[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Object clone()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicMarkableReference;;get;;1;;public java.lang.Object get(boolean[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = $z0;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.atomic.AtomicMarkableReference;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicStampedReference;;get;;1;;public java.lang.Object get(int[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = $i0;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.atomic.AtomicStampedReference;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;acquireQueued;;1;;final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node, long)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node predecessor()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;isQueued;;1;;public final boolean isQueued(java.lang.Thread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;isOnSyncQueue;;1;;final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;transferForSignal;;1;;final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;fullyRelease;;1;;final long fullyRelease(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;owns;;1;;public final boolean owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;hasWaiters;;1;;public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: boolean hasWaiters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;getWaitQueueLength;;1;;public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: int getWaitQueueLength()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;getWaitingThreads;;1;;public final java.util.Collection getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: java.util.Collection getWaitingThreads()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.ReentrantReadWriteLock;;hasWaiters;;1;;public boolean hasWaiters(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantReadWriteLock;;getWaitQueueLength;;1;;public int getWaitQueueLength(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantReadWriteLock;;getWaitingThreads;;1;;protected java.util.Collection getWaitingThreads(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.Attributes;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;write;;1;;void write(java.io.DataOutputStream) throws java.io.IOException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r18);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>("\r\n");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;writeMain;;1;;void writeMain(java.io.DataOutputStream) throws java.io.IOException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r28);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>("\r\n");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;read;;2;;void read(java.util.jar.Manifest$FastInputStream, byte[]) throws java.io.IOException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: int readLine(byte[])>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$b14 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: byte peek()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$b21 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: byte peek()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;5
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b4 = r2[i3];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b6 = r2[$i5];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b7 = r2[0];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b17 = r2[$i16];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b19 = r2[i1];;pattern detected param  r2 must not be null  because used in  ArrayRef 
java.util.jar.Manifest;;<init>;;1;;public void <init>(java.util.jar.Manifest)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = virtualinvoke r1.<java.util.jar.Manifest: java.util.Map getEntries()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Manifest;;make72Safe;;1;;static void make72Safe(java.lang.StringBuffer)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r0.<java.lang.StringBuffer: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.lang.StringBuffer: java.lang.StringBuffer insert(int,java.lang.String)>(i1, "\r\n ");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.jar.Manifest;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r6 = virtualinvoke r2.<java.util.jar.Manifest: java.util.Map getEntries()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.jar.JarEntry;;<init>;;1;;public void <init>(java.util.jar.JarEntry)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.jar.JarEntry: java.util.jar.Attributes attr>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.jar.JarEntry: java.security.cert.Certificate[] certs>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.jar.JarEntry: java.security.CodeSigner[] signers>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.zip.ZipEntry;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.ZipEntry;;<init>;;1;;public void <init>(java.util.zip.ZipEntry)
*;; * ;; * ;;*;;r1;;9
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r1.<java.util.zip.ZipEntry: long time>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l2 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l3 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i4 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.zip.ZipEntry: int flag>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.zip.ZipEntry: byte[] extra>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.zip.ZipEntry: java.lang.String comment>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.jar.JarFile;;getInputStream;;1;;public synchronized java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r10 = virtualinvoke r1.<java.util.zip.ZipEntry: java.lang.String getName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JarFile;;entryNames;;1;;java.util.Enumeration entryNames(java.security.CodeSource[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r5 = r1[i0];;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.zip.ZipFile;;<init>;;2;;public void <init>(java.io.File, int, java.nio.charset.Charset) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r13;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.io.File: java.lang.String getPath()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l5 = virtualinvoke r1.<java.io.File: long lastModified()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipFile;;getEntry;;1;;public java.util.zip.ZipEntry getEntry(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.ZipFile;;getInputStream;;1;;public java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r10;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JarVerifier;;beginEntry;;1;;public void beginEntry(java.util.jar.JarEntry, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r2;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(r4, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;update;;1;;public void update(int, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<sun.security.util.ManifestEntryVerifier: void update(byte)>($b1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;update;;1;;public void update(int, byte[], int, int, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void update(byte[],int,int)>(r1, i1, i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;getCodeSigners;;2;;public java.security.CodeSigner[] getCodeSigners(java.util.jar.JarFile, java.util.jar.JarEntry)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r1.<java.util.jar.JarFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r2.<java.util.jar.JarEntry: java.lang.String getName()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;entryNames;;1;;public synchronized java.util.Enumeration entryNames(java.util.jar.JarFile, java.security.CodeSource[])
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r9 = r2[i0];;pattern detected param  r2 must not be null  because used in  ArrayRef 
java.util.jar.JarVerifier;;isSigningRelated;;1;;static boolean isSigningRelated(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.zip.ZipCoder;;getBytes;;1;;byte[] getBytes(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.lang.String: char[] toCharArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.Inflater;;setInput;;1;;public void setInput(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Inflater;;setDictionary;;1;;public void setDictionary(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Inflater;;inflate;;1;;public int inflate(byte[], int, int) throws java.util.zip.DataFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JavaUtilJarAccessImpl;;jarFileHasClassPathAttribute;;1;;public boolean jarFileHasClassPathAttribute(java.util.jar.JarFile) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.util.jar.JarFile: boolean hasClassPathAttribute()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getCodeSources;;1;;public java.security.CodeSource[] getCodeSources(java.util.jar.JarFile, java.net.URL)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.jar.JarFile: java.security.CodeSource[] getCodeSources(java.net.URL)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getCodeSource;;1;;public java.security.CodeSource getCodeSource(java.util.jar.JarFile, java.net.URL, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.util.jar.JarFile: java.security.CodeSource getCodeSource(java.net.URL,java.lang.String)>(r2, r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;entryNames;;1;;public java.util.Enumeration entryNames(java.util.jar.JarFile, java.security.CodeSource[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.jar.JarFile: java.util.Enumeration entryNames(java.security.CodeSource[])>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;entries2;;1;;public java.util.Enumeration entries2(java.util.jar.JarFile)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.jar.JarFile: java.util.Enumeration entries2()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;setEagerValidation;;1;;public void setEagerValidation(java.util.jar.JarFile, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.jar.JarFile: void setEagerValidation(boolean)>(z0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getManifestDigests;;1;;public java.util.List getManifestDigests(java.util.jar.JarFile)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.jar.JarFile: java.util.List getManifestDigests()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipInputStream;;<init>;;2;;public void <init>(java.io.InputStream, java.nio.charset.Charset)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r8;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r9;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterInputStream;;read;;1;;public int read(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.CRC32;;update;;1;;public void update(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JarOutputStream;;<init>;;1;;public void <init>(java.io.OutputStream, java.util.jar.Manifest) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.jar.JarOutputStream;;putNextEntry;;1;;public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.zip.ZipEntry: byte[] getExtra()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.zip.ZipEntry: void setExtra(byte[])>(r4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipOutputStream;;<init>;;1;;public void <init>(java.io.OutputStream, java.nio.charset.Charset)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.ZipOutputStream;;putNextEntry;;1;;public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;24
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.zip.ZipEntry: long time>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.zip.ZipEntry: void setTime(long)>($l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int method> = $i4;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = 0;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l6 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l8 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l10 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = 8;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l12 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l14 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: long size> = $l14;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l15 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l17 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: long csize> = $l17;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l18 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l19 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l21 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l23 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r7 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r11 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i25 = r1.<java.util.zip.ZipEntry: int flag>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = $i26;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.zip.Deflater;;setInput;;1;;public void setInput(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Deflater;;setDictionary;;1;;public void setDictionary(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Deflater;;deflate;;1;;public int deflate(byte[], int, int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.StreamHandler;;setOutputStream;;1;;protected synchronized void setOutputStream(java.io.OutputStream) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LogRecord;;<init>;;1;;public void <init>(java.util.logging.Level, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LogRecord;;setLevel;;1;;public void setLevel(java.util.logging.Level)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;setFormatter;;1;;public void setFormatter(java.util.logging.Formatter) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Handler;;setErrorManager;;1;;public void setErrorManager(java.util.logging.ErrorManager)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;setLevel;;1;;public synchronized void setLevel(java.util.logging.Level) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;isLoggable;;1;;public boolean isLoggable(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LogManager;;addPropertyChangeListener;;1;;public void addPropertyChangeListener(java.beans.PropertyChangeListener) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LogManager;;addLogger;;1;;public synchronized boolean addLogger(java.util.logging.Logger)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.Logger: java.lang.String getName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Formatter;;formatMessage;;1;;public synchronized java.lang.String formatMessage(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.ResourceBundle getResourceBundle()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r7 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Object[] getParameters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Level;;<init>;;1;;protected void <init>(java.lang.String, int, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Level;;parse;;1;;public static synchronized java.util.logging.Level parse(java.lang.String) throws java.lang.IllegalArgumentException
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r0.<java.lang.String: boolean equals(java.lang.Object)>($r6);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r0.<java.lang.String: boolean equals(java.lang.Object)>($r18);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.logging.Level;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i0 = r2.<java.util.logging.Level: int value>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.logging.SimpleFormatter;;format;;1;;public synchronized java.lang.String format(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;10
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r13 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r15 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r18 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r22 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r23 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;isLoggable;;1;;public boolean isLoggable(java.util.logging.Level)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;addHandler;;1;;public void addHandler(java.util.logging.Handler) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;setParent;;1;;public void setParent(java.util.logging.Logger)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, boolean) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, int, int) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, int, int, boolean) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.XMLFormatter;;format;;1;;public java.lang.String format(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;19
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l3 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l4 = virtualinvoke r1.<java.util.logging.LogRecord: long getSequenceNumber()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r21 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r24 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r26 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r28 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r30 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.util.logging.LogRecord: int getThreadID()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r35 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r39 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.ResourceBundle getResourceBundle()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r40 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r43 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r46 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getResourceBundleName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r49 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Object[] getParameters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r50 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r57 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r58 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logging;;setLoggerLevel;;1;;public void setLoggerLevel(java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LoggingPermission;;<init>;;1;;public void <init>(java.lang.String, java.lang.String) throws java.lang.IllegalArgumentException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("control");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;getLevel;;1;;public java.lang.Object getLevel(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = virtualinvoke $r2.<java.util.logging.Logger: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;setLevel;;1;;public void setLevel(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r3.<java.util.logging.Logger: void setLevel(java.util.logging.Level)>($r4);;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;isLoggable;;1;;public boolean isLoggable(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z0 = virtualinvoke $r3.<java.util.logging.Logger: boolean isLoggable(java.util.logging.Level)>($r4);;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public void log(java.lang.Object, java.lang.Object, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r4.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String)>($r5, r3);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public void log(java.lang.Object, java.lang.Object, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>($r6, r3, r4);;pattern detected param  r1 must not be null it define a local $r5which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public transient void log(java.lang.Object, java.lang.Object, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Object[])>($r6, r3, r4);;pattern detected param  r1 must not be null it define a local $r5which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;getLevelName;;1;;public java.lang.String getLevelName(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = virtualinvoke $r2.<java.util.logging.Level: java.lang.String getName()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.logging.MemoryHandler;;publish;;1;;public synchronized void publish(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.MemoryHandler;;setPushLevel;;1;;public void setPushLevel(java.util.logging.Level) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;<init>;;1;;protected void <init>(java.util.prefs.AbstractPreferences, java.lang.String)
*;; * ;; * ;;*;;r2;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r2.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r2.<java.lang.String: int indexOf(int)>(47);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r2.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;get;;1;;public java.lang.String get(java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;node;;1;;public java.util.prefs.Preferences node(java.lang.String)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("/");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c0 = virtualinvoke r1.<java.lang.String: char charAt(int)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r13 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;nodeExists;;1;;public boolean nodeExists(java.lang.String) throws java.util.prefs.BackingStoreException
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z4 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("/");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c0 = virtualinvoke r1.<java.lang.String: char charAt(int)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r10 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;addPreferenceChangeListener;;1;;public void addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;addNodeChangeListener;;1;;public void addNodeChangeListener(java.util.prefs.NodeChangeListener)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.Base64;;main;;1;;public static void main(java.lang.String[])
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r4 = r0[0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r5 = r0[1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.prefs.XmlSupport;;export;;1;;static void export(java.io.OutputStream, java.util.prefs.Preferences, boolean) throws java.io.IOException, java.util.prefs.BackingStoreException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z1 = virtualinvoke $r8.<java.util.prefs.AbstractPreferences: boolean isRemoved()>();;pattern detected param  r1 must not be null it define a local $r8which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = virtualinvoke r1.<java.util.prefs.Preferences: boolean isUserNode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r7 = virtualinvoke r6.<java.util.prefs.Preferences: java.util.prefs.Preferences parent()>();;pattern detected param  r1 must not be null it define a local r6which used in  InvokeExpr 
java.util.prefs.XmlSupport;;exportMap;;1;;static void exportMap(java.io.OutputStream, java.util.Map) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.XmlSupport;;importMap;;1;;static void importMap(java.io.InputStream, java.util.Map) throws java.io.IOException, java.util.prefs.InvalidPreferencesFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>($r18, $r19);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.UnicodeProp;;forName;;1;;public static java.util.regex.UnicodeProp forName(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.UnicodeProp;;forPOSIXName;;1;;public static java.util.regex.UnicodeProp forPOSIXName(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.zip.Adler32;;update;;1;;public void update(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.DeflaterInputStream;;<init>;;2;;public void <init>(java.io.InputStream, java.util.zip.Deflater, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.DeflaterInputStream;;read;;1;;public int read(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterOutputStream;;<init>;;2;;public void <init>(java.io.OutputStream, java.util.zip.Inflater, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterOutputStream;;write;;1;;public void write(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.WeakHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;hash;;1;;int hash(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i3 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;removeMapping;;1;;boolean removeMapping(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = interfaceinvoke r3.<java.util.Map$Entry: java.lang.Object getKey()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
java.util.AbstractMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.AbstractCollection;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;fill;;1;;public static void fill(long[], long)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = l0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(long[], int, int, long)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = l2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(int[], int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = i0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(int[], int, int, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = i2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(short[], short)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = s0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(short[], int, int, short)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = s2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(char[], char)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = c0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(char[], int, int, char)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = c2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(byte[], byte)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = b0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(byte[], int, int, byte)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = b2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(boolean[], boolean)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = z0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(boolean[], int, int, boolean)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = z0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(double[], double)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(double[], int, int, double)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(float[], float)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(float[], int, int, float)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(java.lang.Object[], java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = r1;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(java.lang.Object[], int, int, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = r1;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;copyOf;;1;;public static java.lang.Object[] copyOf(java.lang.Object[], int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOf;;1;;public static java.lang.Object[] copyOf(java.lang.Object[], int, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Class: java.lang.Class getComponentType()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOfRange;;1;;public static java.lang.Object[] copyOfRange(java.lang.Object[], int, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOfRange;;1;;public static java.lang.Object[] copyOfRange(java.lang.Object[], int, int, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r11 = virtualinvoke r1.<java.lang.Class: java.lang.Class getComponentType()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;deepEquals0;;1;;static boolean deepEquals0(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;z1 = virtualinvoke r0.<java.lang.Object: boolean equals(java.lang.Object)>(r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Locale;;getDefault;;1;;public static java.util.Locale getDefault(java.util.Locale$Category)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r0.<java.util.Locale$Category: int ordinal()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Locale;;setDefault;;2;;public static synchronized void setDefault(java.util.Locale$Category, java.util.Locale)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Locale;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;r2 = $r3.<java.util.Locale: sun.util.locale.BaseLocale baseLocale>;;pattern detected param  r1 must not be null it define a local $r3which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = $r6.<java.util.Locale: sun.util.locale.LocaleExtensions localeExtensions>;;pattern detected param  r1 must not be null it define a local $r6which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r10 = $r9.<java.util.Locale: sun.util.locale.LocaleExtensions localeExtensions>;;pattern detected param  r1 must not be null it define a local $r9which used in  FieldRef 
java.util.AbstractList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractList;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r3 = interfaceinvoke $r6.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null it define a local $r6which used in  InvokeExpr 
java.util.AbstractSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.AbstractSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z4 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractQueue;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.AbstractSequentialList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayDeque;;addFirst;;1;;public void addFirst(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.ArrayDeque;;addLast;;1;;public void addLast(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.ArrayDeque;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.Properties;;loadFromXML;;1;;public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;storeToXML;;1;;public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;storeToXML;;1;;public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;list;;1;;public void list(java.io.PrintStream)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintStream: void println(java.lang.String)>("-- listing properties --");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintStream: void println(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Properties;;list;;1;;public void list(java.io.PrintWriter)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintWriter: void println(java.lang.String)>("-- listing properties --");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintWriter: void println(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;hash;;1;;final int hash(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;transfer;;1;;void transfer(java.util.HashMap$Entry[], boolean)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r8 = r1[i3];;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i3] = r3;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.HashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;removeMapping;;1;;final java.util.HashMap$Entry removeMapping(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r3 = interfaceinvoke r2.<java.util.Map$Entry: java.lang.Object getKey()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.Hashtable;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Hashtable;;contains;;1;;public synchronized boolean contains(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Hashtable;;put;;1;;public synchronized java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.Hashtable;;putAll;;1;;public synchronized void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Hashtable;;equals;;1;;public synchronized boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.ArrayList;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.ArrayList;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(int[], int, int)
*;; * ;; * ;;*;;r0;;23
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i13 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i15 = r0[$i14];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i17 = r0[$i16];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i18 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i19 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i21 = r0[$i20];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i23 = r0[$i22];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i24 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;i6 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i26 = r0[i5];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i4] = $i26;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i5] = i6;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i29 = r0[$i28];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i30 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;$i39 = r2[i38];;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i46 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i47 = r0[i11];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i49 = r0[$i48];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $i49;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i51 = r0[$i50];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $i51;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i56 = r0[i53];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i53] = $i56;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(long[], int, int)
*;; * ;; * ;;*;;r0;;23
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l13 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l15 = r0[$i14];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l18 = r0[$i17];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l19 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l21 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l23 = r0[$i22];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l26 = r0[$i25];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l27 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;l6 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l30 = r0[i5];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i4] = $l30;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i5] = l6;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l33 = r0[$i32];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l34 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;$l44 = r2[i43];;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l51 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l52 = r0[i11];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l55 = r0[$i54];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $l55;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l57 = r0[$i56];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $l57;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l62 = r0[i59];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i59] = $l62;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(short[], int, int)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$s7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = s4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(char[], int, int)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$c7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = c4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(byte[], int, int)
*;; * ;; * ;;*;;r0;;7
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = b4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;b17 = r0[$i16];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b18 = r0[i15];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b20 = r0[i15];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[$i19] = $b20;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[$i22] = b17;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(float[], int, int)
*;; * ;; * ;;*;;r0;;10
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f3 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f0 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f4 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = $f4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f1 = r0[i6];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f5 = r0[i0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f2 = r0[i9];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i9] = 0.0F;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i10] = -0.0F;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(double[], int, int)
*;; * ;; * ;;*;;r0;;10
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d3 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d0 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d4 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = $d4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d1 = r0[i6];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d5 = r0[i0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d2 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i10] = 0.0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i11] = -0.0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.HashSet;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Random;;nextBytes;;1;;public void nextBytes(byte[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = $b7;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(long[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l2 = r0[$i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(java.nio.LongBuffer)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r0.<java.nio.LongBuffer: java.nio.LongBuffer slice()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(java.nio.ByteBuffer)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.nio.ByteBuffer: java.nio.ByteBuffer slice()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.BitSet;;intersects;;1;;public boolean intersects(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;and;;1;;public void and(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r5 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;or;;1;;public void or(java.util.BitSet)
*;; * ;; * ;;*;;r1;;7
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i6 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i7 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i12 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;xor;;1;;public void xor(java.util.BitSet)
*;; * ;; * ;;*;;r1;;8
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i6 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i7 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i12 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i13 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;andNot;;1;;public void andNot(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;specialinvoke r2.<java.util.BitSet: void checkInvariants()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i2 = r2.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.Calendar;;setTime;;1;;public final void setTime(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Calendar;;checkDisplayNameParams;;1;;boolean checkDisplayNameParams(int, int, int, int, java.util.Locale, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Calendar;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$z1 = r2.<java.util.Calendar: boolean lenient>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.Calendar: int firstDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i5 = r2.<java.util.Calendar: int minimalDaysInFirstWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.Calendar: java.util.TimeZone zone>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.TimeZone;;setID;;1;;public void setID(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Date;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$l1 = virtualinvoke $r2.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.Date;;getMillisOf;;1;;static final long getMillisOf(java.util.Date)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r0.<java.util.Date: long fastTime>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
java.util.ResourceBundle;;getBundle;;1;;public static java.util.ResourceBundle getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.ResourceBundle;;clearCache;;1;;public static final void clearCache(java.lang.ClassLoader)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.ResourceBundle;;containsKey;;1;;public boolean containsKey(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;get;;1;;public java.lang.Object get(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;containsKey;;1;;public boolean containsKey(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;containsValue;;1;;public boolean containsValue(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r8;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;putIfAbsent;;1;;public java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;replace;;1;;public java.lang.Object replace(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.GregorianCalendar;;setGregorianChange;;1;;public void setGregorianChange(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.GregorianCalendar;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l1 = $r2.<java.util.GregorianCalendar: long gregorianCutover>;;pattern detected param  r1 must not be null it define a local $r2which used in  FieldRef 
java.util.SimpleTimeZone;;inDaylightTime;;1;;public boolean inDaylightTime(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.SimpleTimeZone;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.SimpleTimeZone: java.lang.String getID()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.SimpleTimeZone;;hasSameRules;;1;;public boolean hasSameRules(java.util.TimeZone)
*;; * ;; * ;;*;;r1;;16
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.SimpleTimeZone: int rawOffset>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$z2 = r2.<java.util.SimpleTimeZone: boolean useDaylight>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.SimpleTimeZone: int dstSavings>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i5 = r2.<java.util.SimpleTimeZone: int startMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i7 = r2.<java.util.SimpleTimeZone: int startMonth>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i9 = r2.<java.util.SimpleTimeZone: int startDay>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i11 = r2.<java.util.SimpleTimeZone: int startDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i13 = r2.<java.util.SimpleTimeZone: int startTime>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i15 = r2.<java.util.SimpleTimeZone: int startTimeMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i17 = r2.<java.util.SimpleTimeZone: int endMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i19 = r2.<java.util.SimpleTimeZone: int endMonth>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i21 = r2.<java.util.SimpleTimeZone: int endDay>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i23 = r2.<java.util.SimpleTimeZone: int endDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i25 = r2.<java.util.SimpleTimeZone: int endTime>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i27 = r2.<java.util.SimpleTimeZone: int endTimeMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i29 = r2.<java.util.SimpleTimeZone: int startYear>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.concurrent.locks.ReentrantLock;;tryLock;;1;;public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.ReentrantLock;;hasWaiters;;1;;public boolean hasWaiters(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantLock;;getWaitQueueLength;;1;;public int getWaitQueueLength(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantLock;;getWaitingThreads;;1;;protected java.util.Collection getWaitingThreads(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Collections;;sort;;1;;public static void sort(java.util.List)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;sort;;1;;public static void sort(java.util.List, java.util.Comparator)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;binarySearch;;1;;public static int binarySearch(java.util.List, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;binarySearch;;1;;public static int binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;reverse;;1;;public static void reverse(java.util.List)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator(int)>(i0);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;shuffle;;2;;public static void shuffle(java.util.List, java.util.Random)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.util.Random: int nextInt(int)>(i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i7 = virtualinvoke r1.<java.util.Random: int nextInt(int)>(i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;swap;;1;;public static void swap(java.util.List, int, int)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i0);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = interfaceinvoke r1.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, $r2);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;interfaceinvoke r1.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i0, $r3);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
java.util.Collections;;fill;;1;;public static void fill(java.util.List, java.lang.Object)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;copy;;2;;public static void copy(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, $r4);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r6 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;min;;1;;public static java.lang.Object min(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;min;;1;;public static java.lang.Object min(java.util.Collection, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;max;;1;;public static java.lang.Object max(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;max;;1;;public static java.lang.Object max(java.util.Collection, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;rotate;;1;;public static void rotate(java.util.List, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;replaceAll;;1;;public static boolean replaceAll(java.util.List, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r0;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i3);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i3, r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r7 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;indexOfSubList;;2;;public static int indexOfSubList(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r5 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;lastIndexOfSubList;;2;;public static int lastIndexOfSubList(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator(int)>(i2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r5 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;list;;1;;public static java.util.ArrayList list(java.util.Enumeration)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r0.<java.util.Enumeration: boolean hasMoreElements()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.Enumeration: java.lang.Object nextElement()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;frequency;;1;;public static int frequency(java.util.Collection, java.lang.Object)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;disjoint;;2;;public static boolean disjoint(java.util.Collection, java.util.Collection)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.Collection: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z3 = interfaceinvoke r2.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r0 must not be null it define a local r2which used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r4 = interfaceinvoke r3.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
java.util.Collections;;addAll;;2;;public static transient boolean addAll(java.util.Collection, java.lang.Object[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.Collection: boolean add(java.lang.Object)>(r3);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r3 = r2[i1];;pattern detected param  r1 must not be null it define a local r2which used in  ArrayRef 
java.util.Currency;;getInstance;;1;;public static java.util.Currency getInstance(java.util.Locale)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = virtualinvoke r0.<java.util.Locale: java.lang.String getCountry()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Pattern;;split;;1;;public java.lang.String[] split(java.lang.CharSequence, int)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i7 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i7);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r11 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.String toString()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i9 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r12 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i9);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.Pattern;;quote;;1;;public static java.lang.String quote(java.lang.String)
*;; * ;; * ;;*;;r0;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r0.<java.lang.String: int indexOf(java.lang.String)>("\\E");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r0.<java.lang.String: int indexOf(java.lang.String,int)>("\\E", i1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r0.<java.lang.String: java.lang.String substring(int,int)>(i1, i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r12 = virtualinvoke r0.<java.lang.String: java.lang.String substring(int,int)>(i1, $i6);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;<init>;;1;;void <init>(java.util.regex.Pattern, java.lang.CharSequence)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i1 = r1.<java.util.regex.Pattern: int capturingGroupCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.regex.Pattern: int localCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.regex.Matcher;;usePattern;;1;;public java.util.regex.Matcher usePattern(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.regex.Matcher;;group;;1;;public java.lang.String group(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.regex.Matcher;;quoteReplacement;;1;;public static java.lang.String quoteReplacement(java.lang.String)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r0.<java.lang.String: int indexOf(int)>(92);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = virtualinvoke r0.<java.lang.String: int indexOf(int)>(36);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c1 = virtualinvoke r0.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;appendReplacement;;2;;public java.util.regex.Matcher appendReplacement(java.lang.StringBuffer, java.lang.String)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence,int,int)>($r35, $i24, $i25);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;8
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c1 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c7 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i6);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c9 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i8);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i11 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c9 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i10);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i15 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c16 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;appendTail;;1;;public java.lang.StringBuffer appendTail(java.lang.StringBuffer)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence,int,int)>($r2, $i0, $i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;replaceFirst;;1;;public java.lang.String replaceFirst(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.StringTokenizer;;<init>;;1;;public void <init>(java.lang.String, java.lang.String, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.DuplicateFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.EnumMap;;<init>;;1;;public void <init>(java.util.EnumMap)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.EnumMap: java.lang.Enum[] keyUniverse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.EnumMap: int size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.EnumMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.EnumMap: java.lang.Enum[] keyUniverse>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i0 = r2.<java.util.EnumMap: int size>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r1.<java.util.Map: boolean isEmpty()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = interfaceinvoke r1.<java.util.Map: java.util.Set keySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.EnumMap;;containsKey;;1;;public boolean containsKey(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;get;;1;;public java.lang.Object get(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;put;;1;;public java.lang.Object put(java.lang.Enum, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.EnumMap;;remove;;1;;public java.lang.Object remove(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z1 = virtualinvoke r2.<java.util.EnumMap: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r8 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r15 = r2.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.EnumMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i2 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r12 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z3 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r13 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.EnumSet;;copyOf;;1;;public static java.util.EnumSet copyOf(java.util.EnumSet)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.util.EnumSet: java.util.EnumSet clone()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;copyOf;;1;;public static java.util.EnumSet copyOf(java.util.Collection)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r5 = virtualinvoke $r4.<java.util.EnumSet: java.util.EnumSet clone()>();;pattern detected param  r0 must not be null it define a local $r4which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.Collection: boolean isEmpty()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;2;;public static transient java.util.EnumSet of(java.lang.Enum, java.lang.Enum[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r4 = r3[i1];;pattern detected param  r1 must not be null it define a local r3which used in  ArrayRef 
java.util.EnumSet;;range;;1;;public static java.util.EnumSet range(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r0.<java.lang.Enum: int compareTo(java.lang.Enum)>(r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;typeCheck;;1;;final void typeCheck(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;addRange;;2;;void addRange(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r1;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i10 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i12 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i18 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i14 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i17 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;add;;1;;public boolean add(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.JumboEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r6 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.JumboEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r15 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.JumboEnumSet: int size>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;addRange;;2;;void addRange(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.RegularEnumSet;;add;;1;;public boolean add(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.RegularEnumSet;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.RegularEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l0 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.RegularEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l4 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l4 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.EventObject;;<init>;;1;;public void <init>(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.FormatFlagsConversionMismatchException;;<init>;;1;;public void <init>(java.lang.String, char)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Objects;;compare;;1;;public static int compare(java.lang.Object, java.lang.Object, java.util.Comparator)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r2.<java.util.Comparator: int compare(java.lang.Object,java.lang.Object)>(r0, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Objects;;requireNonNull;;1;;public static java.lang.Object requireNonNull(java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.Objects;;requireNonNull;;1;;public static java.lang.Object requireNonNull(java.lang.Object, java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.MissingFormatArgumentException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.UnknownFormatConversionException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.LinkedHashMap;;transfer;;1;;void transfer(java.util.HashMap$Entry[], boolean)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r8 = r1[i1];;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i1] = r2;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.LinkedHashSet;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i1 = virtualinvoke r2.<java.util.IdentityHashMap: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;r3 = r2.<java.util.IdentityHashMap: java.lang.Object[] table>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = interfaceinvoke r6.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null it define a local r6which used in  InvokeExpr 
java.util.IllegalFormatConversionException;;<init>;;1;;public void <init>(char, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.IllegalFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.LinkedList;;linkBefore;;1;;void linkBefore(java.lang.Object, java.util.LinkedList$Node)
*;; * ;; * ;;*;;r2;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r2.<java.util.LinkedList$Node: java.util.LinkedList$Node prev>;;pattern detected param  r2 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2.<java.util.LinkedList$Node: java.util.LinkedList$Node prev> = r4;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.LinkedList;;unlink;;1;;java.lang.Object unlink(java.util.LinkedList$Node)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.LinkedList$Node: java.lang.Object item>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.LinkedList$Node: java.util.LinkedList$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r4 = r1.<java.util.LinkedList$Node: java.util.LinkedList$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.util.LinkedList$Node prev> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.util.LinkedList$Node next> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.LinkedList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.LinkedList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[$i4] = $r8;;pattern detected param  r1 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i7] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.ListResourceBundle;;handleGetObject;;1;;public final java.lang.Object handleGetObject(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.PropertyPermission;;implies;;1;;public boolean implies(java.security.Permission)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.PropertyPermission;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.PropertyPermission: java.lang.String getName()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.MissingFormatWidthException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Observable;;addObserver;;1;;public synchronized void addObserver(java.util.Observer)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Vector;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Vector;;toArray;;1;;public synchronized java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.Vector;;addAll;;1;;public synchronized boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Vector;;addAll;;1;;public synchronized boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = interfaceinvoke r2.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r5 = virtualinvoke r4.<java.util.PriorityQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r4which used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.PriorityQueue)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.PriorityQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.PriorityQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.XMLUtils;;importProperties;;2;;static void importProperties(java.util.Properties, org.w3c.dom.Element)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.util.Properties: java.lang.Object setProperty(java.lang.String,java.lang.String)>($r10, r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<org.w3c.dom.Element: org.w3c.dom.NodeList getChildNodes()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.XMLUtils;;save;;1;;static void save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r0;;5
*;;*;;*;;*;;*;;*;;monitorStmt for param;;entermonitor r0;;pattern detected param  r0 must not be null  because used in  monitorStmt 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r24 = virtualinvoke r0.<java.util.Properties: java.util.Set stringPropertyNames()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r28 = virtualinvoke r0.<java.util.Properties: java.lang.String getProperty(java.lang.String)>(r10);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;monitorStmt for local initialized from param;;exitmonitor r23;;pattern detected param  r0 must not be null it define a local r23which used in  monitorStmt 
*;;*;;*;;*;;*;;*;;monitorStmt for local initialized from param;;exitmonitor r23;;pattern detected param  r0 must not be null it define a local r23which used in  monitorStmt 
java.util.PropertyResourceBundle;;handleGetObject;;1;;public java.lang.Object handleGetObject(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;useLocale;;1;;public java.util.Scanner useLocale(java.util.Locale)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.util.Locale: boolean equals(java.lang.Object)>($r4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Scanner;;hasNext;;1;;public boolean hasNext(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;next;;1;;public java.lang.String next(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;findInLine;;1;;public java.lang.String findInLine(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;findWithinHorizon;;1;;public java.lang.String findWithinHorizon(java.util.regex.Pattern, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;skip;;1;;public java.util.Scanner skip(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Timer;;schedule;;1;;public void schedule(java.util.TimerTask, java.util.Date)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Timer;;schedule;;1;;public void schedule(java.util.TimerTask, java.util.Date, long)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Timer;;scheduleAtFixedRate;;1;;public void scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;<init>;;1;;public void <init>(java.util.SortedMap)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r1.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.SortedMap: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.SortedMap: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r2 = interfaceinvoke $r4.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;getEntry;;1;;final java.util.TreeMap$Entry getEntry(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r11;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;compare;;1;;final int compare(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke $r4.<java.lang.Comparable: int compareTo(java.lang.Object)>(r2);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.TreeMap;;key;;1;;static java.lang.Object key(java.util.TreeMap$Entry)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;addAllForTreeSet;;1;;void addAllForTreeSet(java.util.SortedSet, java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.SortedSet: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.SortedSet: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeSet;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r4 = interfaceinvoke r2.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.UnknownFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.UUID;;fromString;;1;;public static java.util.UUID fromString(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = virtualinvoke r0.<java.lang.String: java.lang.String[] split(java.lang.String)>("-");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.UUID;;compareTo;;1;;public int compareTo(java.util.UUID)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.UUID: long mostSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l5 = r1.<java.util.UUID: long mostSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l8 = r1.<java.util.UUID: long leastSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l11 = r1.<java.util.UUID: long leastSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;invokeAny;;1;;public java.lang.Object invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.AbstractExecutorService;;invokeAll;;1;;public java.util.List invokeAll(java.util.Collection) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r9;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.TimeUnit;;timedWait;;1;;public void timedWait(java.lang.Object, long) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: void wait(long,int)>(l1, i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.TimeUnit;;timedJoin;;1;;public void timedJoin(java.lang.Thread, long) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Thread: void join(long,int)>(l1, i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.FutureTask;;<init>;;1;;public void <init>(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.FutureTask;;get;;1;;public java.lang.Object get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ExecutorCompletionService;;<init>;;1;;public void <init>(java.util.concurrent.Executor)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ExecutorCompletionService;;submit;;1;;public java.util.concurrent.Future submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ExecutorCompletionService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;acquireQueued;;1;;final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node predecessor()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;isQueued;;1;;public final boolean isQueued(java.lang.Thread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;isOnSyncQueue;;1;;final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;transferForSignal;;1;;final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;fullyRelease;;1;;final int fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;owns;;1;;public final boolean owns(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;hasWaiters;;1;;public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: boolean hasWaiters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;getWaitQueueLength;;1;;public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: int getWaitQueueLength()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;getWaitingThreads;;1;;public final java.util.Collection getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: java.util.Collection getWaitingThreads()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;<init>;;1;;public void <init>(int, boolean, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i3] = $r9;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.ArrayBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>($r8);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>($r8);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;unlink;;1;;void unlink(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: void lazySetPrev(java.util.concurrent.ConcurrentLinkedDeque$Node)>($r21);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: void lazySetNext(java.util.concurrent.ConcurrentLinkedDeque$Node)>($r23);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;succ;;1;;final java.util.concurrent.ConcurrentLinkedDeque$Node succ(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedDeque;;pred;;1;;final java.util.concurrent.ConcurrentLinkedDeque$Node pred(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;removeFirstOccurrence;;1;;public boolean removeFirstOccurrence(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;removeLastOccurrence;;1;;public boolean removeLastOccurrence(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;updateHead;;1;;final void updateHead(java.util.concurrent.ConcurrentLinkedQueue$Node, java.util.concurrent.ConcurrentLinkedQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedQueue$Node: void lazySetNext(java.util.concurrent.ConcurrentLinkedQueue$Node)>(r1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;succ;;1;;final java.util.concurrent.ConcurrentLinkedQueue$Node succ(java.util.concurrent.ConcurrentLinkedQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedQueue$Node: java.util.concurrent.ConcurrentLinkedQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedQueue;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i2] = r3;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.ConcurrentSkipListMap;;compare;;1;;int compare(java.lang.Object, java.lang.Object) throws java.lang.ClassCastException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i1 = interfaceinvoke $r4.<java.lang.Comparable: int compareTo(java.lang.Object)>(r2);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;inHalfOpenRange;;1;;boolean inHalfOpenRange(java.lang.Object, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;inOpenRange;;1;;boolean inOpenRange(java.lang.Object, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;<init>;;1;;public void <init>(java.util.SortedMap)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;containsValue;;1;;public boolean containsValue(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r11 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>($r10);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r12 = interfaceinvoke r2.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;putIfAbsent;;1;;public java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;remove;;1;;public boolean remove(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;replace;;1;;public java.lang.Object replace(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;headMap;;1;;public java.util.concurrent.ConcurrentNavigableMap headMap(java.lang.Object, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;tailMap;;1;;public java.util.concurrent.ConcurrentNavigableMap tailMap(java.lang.Object, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;toList;;1;;static final java.util.List toList(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Collection: boolean containsAll(java.util.Collection)>(r0);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.CopyOnWriteArrayList;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAllAbsent;;1;;public int addAllAbsent(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CountDownLatch;;await;;1;;public boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CyclicBarrier;;await;;1;;public int await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.BrokenBarrierException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.DelayQueue;;poll;;1;;public java.util.concurrent.Delayed poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.DelayQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.DelayQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Exchanger;;exchange;;1;;public java.lang.Object exchange(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.LockSupport;;getBlocker;;1;;public static java.lang.Object getBlocker(java.lang.Thread)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingQueue;;put;;1;;public void put(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;offer;;2;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingQueue;;unlink;;2;;void unlink(java.util.concurrent.LinkedBlockingQueue$Node, java.util.concurrent.LinkedBlockingQueue$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.LinkedBlockingQueue$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.LinkedBlockingQueue$Node: java.util.concurrent.LinkedBlockingQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2.<java.util.concurrent.LinkedBlockingQueue$Node: java.util.concurrent.LinkedBlockingQueue$Node next> = $r3;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i3] = $r10;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i1] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.LinkedBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;unconfigurableExecutorService;;1;;public static java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;unconfigurableScheduledExecutorService;;1;;public static java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.lang.Runnable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.security.PrivilegedAction)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;privilegedCallable;;1;;public static java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;privilegedCallableUsingCurrentClassLoader;;1;;public static java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;runWorker;;1;;final void runWorker(java.util.concurrent.ThreadPoolExecutor$Worker)
*;; * ;; * ;;*;;r1;;10
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Runnable firstTask>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Runnable firstTask> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void lock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r9 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks> = $l1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void unlock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l2 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks> = $l3;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void unlock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;<init>;;1;;public void <init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l5 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;execute;;1;;public void execute(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;awaitTermination;;1;;public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;setThreadFactory;;1;;public void setThreadFactory(java.util.concurrent.ThreadFactory)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;setRejectedExecutionHandler;;1;;public void setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;setKeepAliveTime;;1;;public void setKeepAliveTime(long, java.util.concurrent.TimeUnit)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;getKeepAliveTime;;1;;public long getKeepAliveTime(java.util.concurrent.TimeUnit)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long convert(long,java.util.concurrent.TimeUnit)>($l0, $r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;put;;1;;public void put(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;offer;;2;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean isEmpty()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.SynchronousQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.ScheduledThreadPoolExecutor;;reExecutePeriodic;;1;;void reExecutePeriodic(java.util.concurrent.RunnableScheduledFuture)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.concurrent.RunnableScheduledFuture: boolean cancel(boolean)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;work;;1;;final void work(java.util.concurrent.ForkJoinWorkerThread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$z1 = r1.<java.util.concurrent.ForkJoinWorkerThread: boolean terminate>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinPool;;tryAwaitJoin;;1;;final void tryAwaitJoin(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void tryAwaitDone(long)>(0L);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;timedAwaitJoin;;1;;final void timedAwaitJoin(java.util.concurrent.ForkJoinTask, long)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i4 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i8 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void tryAwaitDone(long)>(l2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i10 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;deregisterWorker;;1;;final void deregisterWorker(java.util.concurrent.ForkJoinWorkerThread, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;i0 = r1.<java.util.concurrent.ForkJoinWorkerThread: int poolIndex>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;i1 = r1.<java.util.concurrent.ForkJoinWorkerThread: int stealCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinPool;;<init>;;1;;public void <init>(int, java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory, java.lang.Thread$UncaughtExceptionHandler, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;invoke;;1;;public java.lang.Object invoke(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;execute;;1;;public void execute(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;execute;;1;;public void execute(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;invokeAll;;1;;public java.util.List invokeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;drainTasksTo;;1;;protected int drainTasksTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;awaitTermination;;1;;public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;managedBlock;;1;;public static void managedBlock(java.util.concurrent.ForkJoinPool$ManagedBlocker) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.concurrent.ForkJoinPool$ManagedBlocker: boolean isReleasable()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r0.<java.util.concurrent.ForkJoinPool$ManagedBlocker: boolean block()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinWorkerThread;;<init>;;1;;protected void <init>(java.util.concurrent.ForkJoinPool)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.ForkJoinPool: java.lang.String nextWorkerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.util.concurrent.ForkJoinPool: int registerWorker(java.util.concurrent.ForkJoinWorkerThread)>(r0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$z0 = r1.<java.util.concurrent.ForkJoinPool: boolean locallyFifo>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ForkJoinPool: java.lang.Thread$UncaughtExceptionHandler ueh>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinWorkerThread;;drainTasksTo;;1;;final int drainTasksTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinWorkerThread;;joinTask;;1;;final int joinTask(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinTask;;invokeAll;;2;;public static void invokeAll(java.util.concurrent.ForkJoinTask, java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.util.concurrent.ForkJoinTask: java.lang.Object invoke()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: java.util.concurrent.ForkJoinTask fork()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: java.lang.Object join()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinTask;;invokeAll;;1;;public static transient void invokeAll(java.util.concurrent.ForkJoinTask[])
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r2 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r5 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.concurrent.ForkJoinTask;;invokeAll;;1;;public static java.util.Collection invokeAll(java.util.Collection)
*;; * ;; * ;;*;;r0;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = interfaceinvoke r0.<java.util.Collection: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = interfaceinvoke r0.<java.util.Collection: java.lang.Object[] toArray(java.lang.Object[])>($r4);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i3 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r7 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
java.util.concurrent.ForkJoinTask;;get;;1;;public final java.lang.Object get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l7 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toMillis(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;unlink;;1;;void unlink(java.util.concurrent.LinkedBlockingDeque$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.util.concurrent.LinkedBlockingDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.util.concurrent.LinkedBlockingDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedBlockingDeque;;offerFirst;;1;;public boolean offerFirst(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerLast;;1;;public boolean offerLast(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;putFirst;;1;;public void putFirst(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;putLast;;1;;public void putLast(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerFirst;;2;;public boolean offerFirst(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerLast;;2;;public boolean offerLast(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;pollFirst;;1;;public java.lang.Object pollFirst(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;pollLast;;1;;public java.lang.Object pollLast(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i4] = $r9;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.LinkedTransferQueue;;succ;;1;;final java.util.concurrent.LinkedTransferQueue$Node succ(java.util.concurrent.LinkedTransferQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedTransferQueue;;unsplice;;1;;final void unsplice(java.util.concurrent.LinkedTransferQueue$Node, java.util.concurrent.LinkedTransferQueue$Node)
*;; * ;; * ;;*;;r2;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<java.util.concurrent.LinkedTransferQueue$Node: void forgetContents()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r2.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r2 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r8 = r2.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedTransferQueue;;tryTransfer;;1;;public boolean tryTransfer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedTransferQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedTransferQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedTransferQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Phaser;;awaitAdvanceInterruptibly;;1;;public int awaitAdvanceInterruptibly(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r6 = interfaceinvoke r3.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = virtualinvoke r7.<java.util.concurrent.PriorityBlockingQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r7which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = virtualinvoke r7.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null it define a local r7which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r10 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.Semaphore;;tryAcquire;;1;;public boolean tryAcquire(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.Semaphore;;tryAcquire;;1;;public boolean tryAcquire(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicIntegerArray;;<init>;;1;;public void <init>(int[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Object clone()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicLongArray;;<init>;;1;;public void <init>(long[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Object clone()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicMarkableReference;;get;;1;;public java.lang.Object get(boolean[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = $z0;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.atomic.AtomicMarkableReference;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicStampedReference;;get;;1;;public java.lang.Object get(int[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = $i0;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.atomic.AtomicStampedReference;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;acquireQueued;;1;;final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node, long)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node predecessor()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;isQueued;;1;;public final boolean isQueued(java.lang.Thread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;isOnSyncQueue;;1;;final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;transferForSignal;;1;;final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;fullyRelease;;1;;final long fullyRelease(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;owns;;1;;public final boolean owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;hasWaiters;;1;;public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: boolean hasWaiters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;getWaitQueueLength;;1;;public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: int getWaitQueueLength()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;getWaitingThreads;;1;;public final java.util.Collection getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: java.util.Collection getWaitingThreads()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.ReentrantReadWriteLock;;hasWaiters;;1;;public boolean hasWaiters(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantReadWriteLock;;getWaitQueueLength;;1;;public int getWaitQueueLength(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantReadWriteLock;;getWaitingThreads;;1;;protected java.util.Collection getWaitingThreads(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.Attributes;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;write;;1;;void write(java.io.DataOutputStream) throws java.io.IOException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r18);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>("\r\n");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;writeMain;;1;;void writeMain(java.io.DataOutputStream) throws java.io.IOException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r28);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>("\r\n");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;read;;2;;void read(java.util.jar.Manifest$FastInputStream, byte[]) throws java.io.IOException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: int readLine(byte[])>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$b14 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: byte peek()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$b21 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: byte peek()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;5
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b4 = r2[i3];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b6 = r2[$i5];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b7 = r2[0];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b17 = r2[$i16];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b19 = r2[i1];;pattern detected param  r2 must not be null  because used in  ArrayRef 
java.util.jar.Manifest;;<init>;;1;;public void <init>(java.util.jar.Manifest)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = virtualinvoke r1.<java.util.jar.Manifest: java.util.Map getEntries()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Manifest;;make72Safe;;1;;static void make72Safe(java.lang.StringBuffer)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r0.<java.lang.StringBuffer: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.lang.StringBuffer: java.lang.StringBuffer insert(int,java.lang.String)>(i1, "\r\n ");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.jar.Manifest;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r6 = virtualinvoke r2.<java.util.jar.Manifest: java.util.Map getEntries()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.jar.JarEntry;;<init>;;1;;public void <init>(java.util.jar.JarEntry)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.jar.JarEntry: java.util.jar.Attributes attr>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.jar.JarEntry: java.security.cert.Certificate[] certs>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.jar.JarEntry: java.security.CodeSigner[] signers>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.zip.ZipEntry;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.ZipEntry;;<init>;;1;;public void <init>(java.util.zip.ZipEntry)
*;; * ;; * ;;*;;r1;;9
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r1.<java.util.zip.ZipEntry: long time>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l2 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l3 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i4 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.zip.ZipEntry: int flag>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.zip.ZipEntry: byte[] extra>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.zip.ZipEntry: java.lang.String comment>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.jar.JarFile;;getInputStream;;1;;public synchronized java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r10 = virtualinvoke r1.<java.util.zip.ZipEntry: java.lang.String getName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JarFile;;entryNames;;1;;java.util.Enumeration entryNames(java.security.CodeSource[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r5 = r1[i0];;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.zip.ZipFile;;<init>;;2;;public void <init>(java.io.File, int, java.nio.charset.Charset) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r13;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.io.File: java.lang.String getPath()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l5 = virtualinvoke r1.<java.io.File: long lastModified()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipFile;;getEntry;;1;;public java.util.zip.ZipEntry getEntry(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.ZipFile;;getInputStream;;1;;public java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r10;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JarVerifier;;beginEntry;;1;;public void beginEntry(java.util.jar.JarEntry, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r2;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(r4, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;update;;1;;public void update(int, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<sun.security.util.ManifestEntryVerifier: void update(byte)>($b1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;update;;1;;public void update(int, byte[], int, int, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void update(byte[],int,int)>(r1, i1, i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;getCodeSigners;;2;;public java.security.CodeSigner[] getCodeSigners(java.util.jar.JarFile, java.util.jar.JarEntry)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r1.<java.util.jar.JarFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r2.<java.util.jar.JarEntry: java.lang.String getName()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;entryNames;;1;;public synchronized java.util.Enumeration entryNames(java.util.jar.JarFile, java.security.CodeSource[])
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r9 = r2[i0];;pattern detected param  r2 must not be null  because used in  ArrayRef 
java.util.jar.JarVerifier;;isSigningRelated;;1;;static boolean isSigningRelated(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.zip.ZipCoder;;getBytes;;1;;byte[] getBytes(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.lang.String: char[] toCharArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.Inflater;;setInput;;1;;public void setInput(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Inflater;;setDictionary;;1;;public void setDictionary(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Inflater;;inflate;;1;;public int inflate(byte[], int, int) throws java.util.zip.DataFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JavaUtilJarAccessImpl;;jarFileHasClassPathAttribute;;1;;public boolean jarFileHasClassPathAttribute(java.util.jar.JarFile) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.util.jar.JarFile: boolean hasClassPathAttribute()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getCodeSources;;1;;public java.security.CodeSource[] getCodeSources(java.util.jar.JarFile, java.net.URL)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.jar.JarFile: java.security.CodeSource[] getCodeSources(java.net.URL)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getCodeSource;;1;;public java.security.CodeSource getCodeSource(java.util.jar.JarFile, java.net.URL, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.util.jar.JarFile: java.security.CodeSource getCodeSource(java.net.URL,java.lang.String)>(r2, r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;entryNames;;1;;public java.util.Enumeration entryNames(java.util.jar.JarFile, java.security.CodeSource[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.jar.JarFile: java.util.Enumeration entryNames(java.security.CodeSource[])>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;entries2;;1;;public java.util.Enumeration entries2(java.util.jar.JarFile)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.jar.JarFile: java.util.Enumeration entries2()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;setEagerValidation;;1;;public void setEagerValidation(java.util.jar.JarFile, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.jar.JarFile: void setEagerValidation(boolean)>(z0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getManifestDigests;;1;;public java.util.List getManifestDigests(java.util.jar.JarFile)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.jar.JarFile: java.util.List getManifestDigests()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipInputStream;;<init>;;2;;public void <init>(java.io.InputStream, java.nio.charset.Charset)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r8;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r9;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterInputStream;;read;;1;;public int read(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.CRC32;;update;;1;;public void update(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JarOutputStream;;<init>;;1;;public void <init>(java.io.OutputStream, java.util.jar.Manifest) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.jar.JarOutputStream;;putNextEntry;;1;;public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.zip.ZipEntry: byte[] getExtra()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.zip.ZipEntry: void setExtra(byte[])>(r4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipOutputStream;;<init>;;1;;public void <init>(java.io.OutputStream, java.nio.charset.Charset)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.ZipOutputStream;;putNextEntry;;1;;public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;24
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.zip.ZipEntry: long time>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.zip.ZipEntry: void setTime(long)>($l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int method> = $i4;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = 0;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l6 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l8 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l10 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = 8;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l12 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l14 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: long size> = $l14;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l15 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l17 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: long csize> = $l17;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l18 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l19 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l21 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l23 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r7 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r11 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i25 = r1.<java.util.zip.ZipEntry: int flag>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = $i26;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.zip.Deflater;;setInput;;1;;public void setInput(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Deflater;;setDictionary;;1;;public void setDictionary(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Deflater;;deflate;;1;;public int deflate(byte[], int, int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.StreamHandler;;setOutputStream;;1;;protected synchronized void setOutputStream(java.io.OutputStream) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LogRecord;;<init>;;1;;public void <init>(java.util.logging.Level, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LogRecord;;setLevel;;1;;public void setLevel(java.util.logging.Level)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;setFormatter;;1;;public void setFormatter(java.util.logging.Formatter) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Handler;;setErrorManager;;1;;public void setErrorManager(java.util.logging.ErrorManager)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;setLevel;;1;;public synchronized void setLevel(java.util.logging.Level) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;isLoggable;;1;;public boolean isLoggable(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LogManager;;addPropertyChangeListener;;1;;public void addPropertyChangeListener(java.beans.PropertyChangeListener) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LogManager;;addLogger;;1;;public synchronized boolean addLogger(java.util.logging.Logger)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.Logger: java.lang.String getName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Formatter;;formatMessage;;1;;public synchronized java.lang.String formatMessage(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.ResourceBundle getResourceBundle()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r7 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Object[] getParameters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Level;;<init>;;1;;protected void <init>(java.lang.String, int, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Level;;parse;;1;;public static synchronized java.util.logging.Level parse(java.lang.String) throws java.lang.IllegalArgumentException
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r0.<java.lang.String: boolean equals(java.lang.Object)>($r6);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r0.<java.lang.String: boolean equals(java.lang.Object)>($r18);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.logging.Level;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i0 = r2.<java.util.logging.Level: int value>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.logging.SimpleFormatter;;format;;1;;public synchronized java.lang.String format(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;10
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r13 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r15 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r18 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r22 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r23 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;isLoggable;;1;;public boolean isLoggable(java.util.logging.Level)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;addHandler;;1;;public void addHandler(java.util.logging.Handler) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;setParent;;1;;public void setParent(java.util.logging.Logger)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, boolean) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, int, int) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, int, int, boolean) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.XMLFormatter;;format;;1;;public java.lang.String format(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;19
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l3 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l4 = virtualinvoke r1.<java.util.logging.LogRecord: long getSequenceNumber()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r21 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r24 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r26 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r28 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r30 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.util.logging.LogRecord: int getThreadID()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r35 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r39 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.ResourceBundle getResourceBundle()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r40 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r43 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r46 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getResourceBundleName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r49 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Object[] getParameters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r50 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r57 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r58 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logging;;setLoggerLevel;;1;;public void setLoggerLevel(java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LoggingPermission;;<init>;;1;;public void <init>(java.lang.String, java.lang.String) throws java.lang.IllegalArgumentException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("control");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;getLevel;;1;;public java.lang.Object getLevel(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = virtualinvoke $r2.<java.util.logging.Logger: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;setLevel;;1;;public void setLevel(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r3.<java.util.logging.Logger: void setLevel(java.util.logging.Level)>($r4);;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;isLoggable;;1;;public boolean isLoggable(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z0 = virtualinvoke $r3.<java.util.logging.Logger: boolean isLoggable(java.util.logging.Level)>($r4);;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public void log(java.lang.Object, java.lang.Object, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r4.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String)>($r5, r3);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public void log(java.lang.Object, java.lang.Object, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>($r6, r3, r4);;pattern detected param  r1 must not be null it define a local $r5which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public transient void log(java.lang.Object, java.lang.Object, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Object[])>($r6, r3, r4);;pattern detected param  r1 must not be null it define a local $r5which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;getLevelName;;1;;public java.lang.String getLevelName(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = virtualinvoke $r2.<java.util.logging.Level: java.lang.String getName()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.logging.MemoryHandler;;publish;;1;;public synchronized void publish(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.MemoryHandler;;setPushLevel;;1;;public void setPushLevel(java.util.logging.Level) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;<init>;;1;;protected void <init>(java.util.prefs.AbstractPreferences, java.lang.String)
*;; * ;; * ;;*;;r2;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r2.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r2.<java.lang.String: int indexOf(int)>(47);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r2.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;get;;1;;public java.lang.String get(java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;node;;1;;public java.util.prefs.Preferences node(java.lang.String)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("/");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c0 = virtualinvoke r1.<java.lang.String: char charAt(int)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r13 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;nodeExists;;1;;public boolean nodeExists(java.lang.String) throws java.util.prefs.BackingStoreException
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z4 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("/");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c0 = virtualinvoke r1.<java.lang.String: char charAt(int)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r10 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;addPreferenceChangeListener;;1;;public void addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;addNodeChangeListener;;1;;public void addNodeChangeListener(java.util.prefs.NodeChangeListener)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.Base64;;main;;1;;public static void main(java.lang.String[])
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r4 = r0[0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r5 = r0[1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.prefs.XmlSupport;;export;;1;;static void export(java.io.OutputStream, java.util.prefs.Preferences, boolean) throws java.io.IOException, java.util.prefs.BackingStoreException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z1 = virtualinvoke $r8.<java.util.prefs.AbstractPreferences: boolean isRemoved()>();;pattern detected param  r1 must not be null it define a local $r8which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = virtualinvoke r1.<java.util.prefs.Preferences: boolean isUserNode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r7 = virtualinvoke r6.<java.util.prefs.Preferences: java.util.prefs.Preferences parent()>();;pattern detected param  r1 must not be null it define a local r6which used in  InvokeExpr 
java.util.prefs.XmlSupport;;exportMap;;1;;static void exportMap(java.io.OutputStream, java.util.Map) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.XmlSupport;;importMap;;1;;static void importMap(java.io.InputStream, java.util.Map) throws java.io.IOException, java.util.prefs.InvalidPreferencesFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>($r18, $r19);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.UnicodeProp;;forName;;1;;public static java.util.regex.UnicodeProp forName(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.UnicodeProp;;forPOSIXName;;1;;public static java.util.regex.UnicodeProp forPOSIXName(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.zip.Adler32;;update;;1;;public void update(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.DeflaterInputStream;;<init>;;2;;public void <init>(java.io.InputStream, java.util.zip.Deflater, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.DeflaterInputStream;;read;;1;;public int read(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterOutputStream;;<init>;;2;;public void <init>(java.io.OutputStream, java.util.zip.Inflater, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterOutputStream;;write;;1;;public void write(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.WeakHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;hash;;1;;int hash(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i3 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.WeakHashMap;;removeMapping;;1;;boolean removeMapping(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = interfaceinvoke r3.<java.util.Map$Entry: java.lang.Object getKey()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
java.util.AbstractMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.AbstractCollection;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractCollection;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;fill;;1;;public static void fill(long[], long)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = l0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(long[], int, int, long)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = l2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(int[], int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = i0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(int[], int, int, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = i2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(short[], short)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = s0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(short[], int, int, short)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = s2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(char[], char)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = c0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(char[], int, int, char)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = c2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(byte[], byte)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = b0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(byte[], int, int, byte)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = b2;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(boolean[], boolean)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = z0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(boolean[], int, int, boolean)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = z0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(double[], double)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(double[], int, int, double)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(float[], float)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(float[], int, int, float)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(java.lang.Object[], java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i0] = r1;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;fill;;1;;public static void fill(java.lang.Object[], int, int, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = r1;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.Arrays;;copyOf;;1;;public static java.lang.Object[] copyOf(java.lang.Object[], int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOf;;1;;public static java.lang.Object[] copyOf(java.lang.Object[], int, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Class: java.lang.Class getComponentType()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOfRange;;1;;public static java.lang.Object[] copyOfRange(java.lang.Object[], int, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Arrays;;copyOfRange;;1;;public static java.lang.Object[] copyOfRange(java.lang.Object[], int, int, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r11 = virtualinvoke r1.<java.lang.Class: java.lang.Class getComponentType()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Arrays;;deepEquals0;;1;;static boolean deepEquals0(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;z1 = virtualinvoke r0.<java.lang.Object: boolean equals(java.lang.Object)>(r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Locale;;getDefault;;1;;public static java.util.Locale getDefault(java.util.Locale$Category)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r0.<java.util.Locale$Category: int ordinal()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Locale;;setDefault;;2;;public static synchronized void setDefault(java.util.Locale$Category, java.util.Locale)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Locale;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;r2 = $r3.<java.util.Locale: sun.util.locale.BaseLocale baseLocale>;;pattern detected param  r1 must not be null it define a local $r3which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = $r6.<java.util.Locale: sun.util.locale.LocaleExtensions localeExtensions>;;pattern detected param  r1 must not be null it define a local $r6which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r10 = $r9.<java.util.Locale: sun.util.locale.LocaleExtensions localeExtensions>;;pattern detected param  r1 must not be null it define a local $r9which used in  FieldRef 
java.util.AbstractList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractList;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r3 = interfaceinvoke $r6.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null it define a local $r6which used in  InvokeExpr 
java.util.AbstractSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.AbstractSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z4 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>($r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.AbstractQueue;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.AbstractSequentialList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayDeque;;addFirst;;1;;public void addFirst(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.ArrayDeque;;addLast;;1;;public void addLast(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.ArrayDeque;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.Properties;;loadFromXML;;1;;public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;storeToXML;;1;;public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;storeToXML;;1;;public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Properties;;list;;1;;public void list(java.io.PrintStream)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintStream: void println(java.lang.String)>("-- listing properties --");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintStream: void println(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Properties;;list;;1;;public void list(java.io.PrintWriter)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintWriter: void println(java.lang.String)>("-- listing properties --");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.PrintWriter: void println(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;hash;;1;;final int hash(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Object: int hashCode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;transfer;;1;;void transfer(java.util.HashMap$Entry[], boolean)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r8 = r1[i3];;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i3] = r3;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.HashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.HashMap;;removeMapping;;1;;final java.util.HashMap$Entry removeMapping(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r3 = interfaceinvoke r2.<java.util.Map$Entry: java.lang.Object getKey()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.Hashtable;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Hashtable;;contains;;1;;public synchronized boolean contains(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Hashtable;;put;;1;;public synchronized java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.Hashtable;;putAll;;1;;public synchronized void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Hashtable;;equals;;1;;public synchronized boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r5);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.ArrayList;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.ArrayList;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.ArrayList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(int[], int, int)
*;; * ;; * ;;*;;r0;;23
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i13 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i15 = r0[$i14];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i17 = r0[$i16];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i18 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i19 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i21 = r0[$i20];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i23 = r0[$i22];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i24 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;i6 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i26 = r0[i5];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i4] = $i26;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i5] = i6;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i29 = r0[$i28];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i30 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;$i39 = r2[i38];;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i46 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i47 = r0[i11];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i49 = r0[$i48];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $i49;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i51 = r0[$i50];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $i51;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$i56 = r0[i53];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i53] = $i56;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(long[], int, int)
*;; * ;; * ;;*;;r0;;23
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l13 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l15 = r0[$i14];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l18 = r0[$i17];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l19 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l21 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l23 = r0[$i22];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l26 = r0[$i25];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l27 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;l6 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l30 = r0[i5];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i4] = $l30;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i5] = l6;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l33 = r0[$i32];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l34 = r0[i3];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;$l44 = r2[i43];;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l51 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l52 = r0[i11];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l55 = r0[$i54];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $l55;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l57 = r0[$i56];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i9] = $l57;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l62 = r0[i59];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[i59] = $l62;;pattern detected param  r0 must not be null it define a local r2which used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(short[], int, int)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$s7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = s4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(char[], int, int)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$c7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = c4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(byte[], int, int)
*;; * ;; * ;;*;;r0;;7
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b7 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i3] = b4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;b17 = r0[$i16];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b18 = r0[i15];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b20 = r0[i15];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[$i19] = $b20;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[$i22] = b17;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(float[], int, int)
*;; * ;; * ;;*;;r0;;10
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f3 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f0 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f4 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = $f4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = f0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f1 = r0[i6];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$f5 = r0[i0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;f2 = r0[i9];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i9] = 0.0F;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i10] = -0.0F;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.DualPivotQuicksort;;sort;;1;;public static void sort(double[], int, int)
*;; * ;; * ;;*;;r0;;10
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d3 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d0 = r0[i2];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d4 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i2] = $d4;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i1] = d0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d1 = r0[i6];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$d5 = r0[i0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;d2 = r0[i10];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i10] = 0.0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r0[i11] = -0.0;;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.HashSet;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Random;;nextBytes;;1;;public void nextBytes(byte[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = $b7;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(long[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$l2 = r0[$i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(java.nio.LongBuffer)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r0.<java.nio.LongBuffer: java.nio.LongBuffer slice()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.BitSet;;valueOf;;1;;public static java.util.BitSet valueOf(java.nio.ByteBuffer)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.nio.ByteBuffer: java.nio.ByteBuffer slice()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.BitSet;;intersects;;1;;public boolean intersects(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;and;;1;;public void and(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r5 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;or;;1;;public void or(java.util.BitSet)
*;; * ;; * ;;*;;r1;;7
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i6 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i7 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i12 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;xor;;1;;public void xor(java.util.BitSet)
*;; * ;; * ;;*;;r1;;8
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i6 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i7 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i12 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i13 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;andNot;;1;;public void andNot(java.util.BitSet)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.BitSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;specialinvoke r2.<java.util.BitSet: void checkInvariants()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i2 = r2.<java.util.BitSet: int wordsInUse>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.BitSet: long[] words>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.Calendar;;setTime;;1;;public final void setTime(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Calendar;;checkDisplayNameParams;;1;;boolean checkDisplayNameParams(int, int, int, int, java.util.Locale, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Calendar;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$z1 = r2.<java.util.Calendar: boolean lenient>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.Calendar: int firstDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i5 = r2.<java.util.Calendar: int minimalDaysInFirstWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.Calendar: java.util.TimeZone zone>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.TimeZone;;setID;;1;;public void setID(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Date;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$l1 = virtualinvoke $r2.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.Date;;getMillisOf;;1;;static final long getMillisOf(java.util.Date)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r0.<java.util.Date: long fastTime>;;pattern detected param  r0 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r0.<java.util.Date: sun.util.calendar.BaseCalendar$Date cdate>;;pattern detected param  r0 must not be null  because used in  FieldRef 
java.util.ResourceBundle;;getBundle;;1;;public static java.util.ResourceBundle getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.ResourceBundle;;clearCache;;1;;public static final void clearCache(java.lang.ClassLoader)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.ResourceBundle;;containsKey;;1;;public boolean containsKey(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;get;;1;;public java.lang.Object get(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;containsKey;;1;;public boolean containsKey(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;containsValue;;1;;public boolean containsValue(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r8;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;putIfAbsent;;1;;public java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentHashMap;;replace;;1;;public java.lang.Object replace(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.GregorianCalendar;;setGregorianChange;;1;;public void setGregorianChange(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.GregorianCalendar;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l1 = $r2.<java.util.GregorianCalendar: long gregorianCutover>;;pattern detected param  r1 must not be null it define a local $r2which used in  FieldRef 
java.util.SimpleTimeZone;;inDaylightTime;;1;;public boolean inDaylightTime(java.util.Date)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.Date: long getTime()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.SimpleTimeZone;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.SimpleTimeZone: java.lang.String getID()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.SimpleTimeZone;;hasSameRules;;1;;public boolean hasSameRules(java.util.TimeZone)
*;; * ;; * ;;*;;r1;;16
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.SimpleTimeZone: int rawOffset>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$z2 = r2.<java.util.SimpleTimeZone: boolean useDaylight>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.SimpleTimeZone: int dstSavings>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i5 = r2.<java.util.SimpleTimeZone: int startMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i7 = r2.<java.util.SimpleTimeZone: int startMonth>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i9 = r2.<java.util.SimpleTimeZone: int startDay>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i11 = r2.<java.util.SimpleTimeZone: int startDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i13 = r2.<java.util.SimpleTimeZone: int startTime>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i15 = r2.<java.util.SimpleTimeZone: int startTimeMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i17 = r2.<java.util.SimpleTimeZone: int endMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i19 = r2.<java.util.SimpleTimeZone: int endMonth>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i21 = r2.<java.util.SimpleTimeZone: int endDay>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i23 = r2.<java.util.SimpleTimeZone: int endDayOfWeek>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i25 = r2.<java.util.SimpleTimeZone: int endTime>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i27 = r2.<java.util.SimpleTimeZone: int endTimeMode>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i29 = r2.<java.util.SimpleTimeZone: int startYear>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.concurrent.locks.ReentrantLock;;tryLock;;1;;public boolean tryLock(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.ReentrantLock;;hasWaiters;;1;;public boolean hasWaiters(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantLock;;getWaitQueueLength;;1;;public int getWaitQueueLength(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantLock;;getWaitingThreads;;1;;protected java.util.Collection getWaitingThreads(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Collections;;sort;;1;;public static void sort(java.util.List)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;sort;;1;;public static void sort(java.util.List, java.util.Comparator)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;binarySearch;;1;;public static int binarySearch(java.util.List, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;binarySearch;;1;;public static int binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;reverse;;1;;public static void reverse(java.util.List)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator(int)>(i0);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;shuffle;;2;;public static void shuffle(java.util.List, java.util.Random)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.List: java.lang.Object[] toArray()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.util.Random: int nextInt(int)>(i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i7 = virtualinvoke r1.<java.util.Random: int nextInt(int)>(i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;swap;;1;;public static void swap(java.util.List, int, int)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i0);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = interfaceinvoke r1.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, $r2);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;interfaceinvoke r1.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i0, $r3);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
java.util.Collections;;fill;;1;;public static void fill(java.util.List, java.lang.Object)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;copy;;2;;public static void copy(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, $r4);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r6 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;min;;1;;public static java.lang.Object min(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;min;;1;;public static java.lang.Object min(java.util.Collection, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;max;;1;;public static java.lang.Object max(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;max;;1;;public static java.lang.Object max(java.util.Collection, java.util.Comparator)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;rotate;;1;;public static void rotate(java.util.List, int)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;replaceAll;;1;;public static boolean replaceAll(java.util.List, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r0;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i1, r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i3);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r0.<java.util.List: java.lang.Object set(int,java.lang.Object)>(i3, r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r7 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;indexOfSubList;;2;;public static int indexOfSubList(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r5 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;lastIndexOfSubList;;2;;public static int lastIndexOfSubList(java.util.List, java.util.List)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.List: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.List: java.util.ListIterator listIterator(int)>(i2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r5 = interfaceinvoke r1.<java.util.List: java.util.ListIterator listIterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Collections;;list;;1;;public static java.util.ArrayList list(java.util.Enumeration)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r0.<java.util.Enumeration: boolean hasMoreElements()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r0.<java.util.Enumeration: java.lang.Object nextElement()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;frequency;;1;;public static int frequency(java.util.Collection, java.lang.Object)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.Collections;;disjoint;;2;;public static boolean disjoint(java.util.Collection, java.util.Collection)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r0.<java.util.Collection: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z3 = interfaceinvoke r2.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r0 must not be null it define a local r2which used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r4 = interfaceinvoke r3.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
java.util.Collections;;addAll;;2;;public static transient boolean addAll(java.util.Collection, java.lang.Object[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.Collection: boolean add(java.lang.Object)>(r3);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r3 = r2[i1];;pattern detected param  r1 must not be null it define a local r2which used in  ArrayRef 
java.util.Currency;;getInstance;;1;;public static java.util.Currency getInstance(java.util.Locale)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = virtualinvoke r0.<java.util.Locale: java.lang.String getCountry()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Pattern;;split;;1;;public java.lang.String[] split(java.lang.CharSequence, int)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i7 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i7);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r11 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.String toString()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i9 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r12 = interfaceinvoke r1.<java.lang.CharSequence: java.lang.CharSequence subSequence(int,int)>(i1, $i9);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.Pattern;;quote;;1;;public static java.lang.String quote(java.lang.String)
*;; * ;; * ;;*;;r0;;6
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r0.<java.lang.String: int indexOf(java.lang.String)>("\\E");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r0.<java.lang.String: int indexOf(java.lang.String,int)>("\\E", i1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r0.<java.lang.String: java.lang.String substring(int,int)>(i1, i5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r12 = virtualinvoke r0.<java.lang.String: java.lang.String substring(int,int)>(i1, $i6);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;<init>;;1;;void <init>(java.util.regex.Pattern, java.lang.CharSequence)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i1 = r1.<java.util.regex.Pattern: int capturingGroupCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.regex.Pattern: int localCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.regex.Matcher;;usePattern;;1;;public java.util.regex.Matcher usePattern(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.regex.Matcher;;group;;1;;public java.lang.String group(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.regex.Matcher;;quoteReplacement;;1;;public static java.lang.String quoteReplacement(java.lang.String)
*;; * ;; * ;;*;;r0;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r0.<java.lang.String: int indexOf(int)>(92);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = virtualinvoke r0.<java.lang.String: int indexOf(int)>(36);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c1 = virtualinvoke r0.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;appendReplacement;;2;;public java.util.regex.Matcher appendReplacement(java.lang.StringBuffer, java.lang.String)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence,int,int)>($r35, $i24, $i25);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;8
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c1 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c7 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i6);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c9 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i8);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i11 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;c9 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i10);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i15 = virtualinvoke r2.<java.lang.String: int length()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c16 = virtualinvoke r2.<java.lang.String: char charAt(int)>(i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;appendTail;;1;;public java.lang.StringBuffer appendTail(java.lang.StringBuffer)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence,int,int)>($r2, $i0, $i1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.Matcher;;replaceFirst;;1;;public java.lang.String replaceFirst(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.StringTokenizer;;<init>;;1;;public void <init>(java.lang.String, java.lang.String, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.DuplicateFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.EnumMap;;<init>;;1;;public void <init>(java.util.EnumMap)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.EnumMap: java.lang.Enum[] keyUniverse>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.EnumMap: int size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.EnumMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.EnumMap: java.lang.Enum[] keyUniverse>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i0 = r2.<java.util.EnumMap: int size>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r1.<java.util.Map: boolean isEmpty()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = interfaceinvoke r1.<java.util.Map: java.util.Set keySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.EnumMap;;containsKey;;1;;public boolean containsKey(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;get;;1;;public java.lang.Object get(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;put;;1;;public java.lang.Object put(java.lang.Enum, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.EnumMap;;remove;;1;;public java.lang.Object remove(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;i0 = virtualinvoke $r3.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.EnumMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z1 = virtualinvoke r2.<java.util.EnumMap: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r8 = r2.<java.util.EnumMap: java.lang.Class keyType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r15 = r2.<java.util.EnumMap: java.lang.Object[] vals>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.EnumMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i2 = interfaceinvoke r2.<java.util.Map: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r12 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z3 = interfaceinvoke r2.<java.util.Map: boolean containsKey(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r13 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>(r3);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.EnumSet;;copyOf;;1;;public static java.util.EnumSet copyOf(java.util.EnumSet)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r1 = virtualinvoke r0.<java.util.EnumSet: java.util.EnumSet clone()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;copyOf;;1;;public static java.util.EnumSet copyOf(java.util.Collection)
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r5 = virtualinvoke $r4.<java.util.EnumSet: java.util.EnumSet clone()>();;pattern detected param  r0 must not be null it define a local $r4which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.Collection: boolean isEmpty()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;1;;public static java.util.EnumSet of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;of;;2;;public static transient java.util.EnumSet of(java.lang.Enum, java.lang.Enum[])
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r4 = r3[i1];;pattern detected param  r1 must not be null it define a local r3which used in  ArrayRef 
java.util.EnumSet;;range;;1;;public static java.util.EnumSet range(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r0.<java.lang.Enum: int compareTo(java.lang.Enum)>(r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r0.<java.lang.Enum: java.lang.Class getDeclaringClass()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.EnumSet;;typeCheck;;1;;final void typeCheck(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;addRange;;2;;void addRange(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r1;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i3 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i10 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i12 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i18 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i4 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i6 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i14 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i17 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;add;;1;;public boolean add(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.JumboEnumSet;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.JumboEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r6 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.JumboEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r15 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.JumboEnumSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.JumboEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.JumboEnumSet: int size>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r5 = r2.<java.util.JumboEnumSet: long[] elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;addRange;;2;;void addRange(java.lang.Enum, java.lang.Enum)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = virtualinvoke r2.<java.lang.Enum: int ordinal()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.RegularEnumSet;;add;;1;;public boolean add(java.lang.Enum)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.Enum: int ordinal()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.RegularEnumSet;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.RegularEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l0 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r4 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = virtualinvoke r2.<java.util.RegularEnumSet: boolean isEmpty()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r7 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l4 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.RegularEnumSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$r3 = r2.<java.util.RegularEnumSet: java.lang.Class elementType>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l2 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$l4 = r2.<java.util.RegularEnumSet: long elements>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.EventObject;;<init>;;1;;public void <init>(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.FormatFlagsConversionMismatchException;;<init>;;1;;public void <init>(java.lang.String, char)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Objects;;compare;;1;;public static int compare(java.lang.Object, java.lang.Object, java.util.Comparator)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r2.<java.util.Comparator: int compare(java.lang.Object,java.lang.Object)>(r0, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Objects;;requireNonNull;;1;;public static java.lang.Object requireNonNull(java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.Objects;;requireNonNull;;1;;public static java.lang.Object requireNonNull(java.lang.Object, java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.MissingFormatArgumentException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.UnknownFormatConversionException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.LinkedHashMap;;transfer;;1;;void transfer(java.util.HashMap$Entry[], boolean)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r8 = r1[i1];;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i1] = r2;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.LinkedHashSet;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;<init>;;1;;public void <init>(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.IdentityHashMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i1 = virtualinvoke r2.<java.util.IdentityHashMap: int size()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;r3 = r2.<java.util.IdentityHashMap: java.lang.Object[] table>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = interfaceinvoke r6.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null it define a local r6which used in  InvokeExpr 
java.util.IllegalFormatConversionException;;<init>;;1;;public void <init>(char, java.lang.Class)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.IllegalFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.LinkedList;;linkBefore;;1;;void linkBefore(java.lang.Object, java.util.LinkedList$Node)
*;; * ;; * ;;*;;r2;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r2.<java.util.LinkedList$Node: java.util.LinkedList$Node prev>;;pattern detected param  r2 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2.<java.util.LinkedList$Node: java.util.LinkedList$Node prev> = r4;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.LinkedList;;unlink;;1;;java.lang.Object unlink(java.util.LinkedList$Node)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.LinkedList$Node: java.lang.Object item>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.LinkedList$Node: java.util.LinkedList$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r4 = r1.<java.util.LinkedList$Node: java.util.LinkedList$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.util.LinkedList$Node prev> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.util.LinkedList$Node next> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.LinkedList$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.LinkedList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.LinkedList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for local initialized from param;;r2[$i4] = $r8;;pattern detected param  r1 must not be null it define a local r2which used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i7] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.ListResourceBundle;;handleGetObject;;1;;public final java.lang.Object handleGetObject(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.PropertyPermission;;implies;;1;;public boolean implies(java.security.Permission)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i3 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.PropertyPermission;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i1 = r2.<java.util.PropertyPermission: int mask>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.PropertyPermission: java.lang.String getName()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.MissingFormatWidthException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Observable;;addObserver;;1;;public synchronized void addObserver(java.util.Observer)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Vector;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Vector;;toArray;;1;;public synchronized java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.Vector;;addAll;;1;;public synchronized boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Vector;;addAll;;1;;public synchronized boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = interfaceinvoke r2.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r5 = virtualinvoke r4.<java.util.PriorityQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r4which used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.PriorityQueue)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.PriorityQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.PriorityQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.PriorityQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i6] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.XMLUtils;;importProperties;;2;;static void importProperties(java.util.Properties, org.w3c.dom.Element)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.util.Properties: java.lang.Object setProperty(java.lang.String,java.lang.String)>($r10, r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<org.w3c.dom.Element: org.w3c.dom.NodeList getChildNodes()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.XMLUtils;;save;;1;;static void save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException
*;; * ;; * ;;*;;r0;;5
*;;*;;*;;*;;*;;*;;monitorStmt for param;;entermonitor r0;;pattern detected param  r0 must not be null  because used in  monitorStmt 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r24 = virtualinvoke r0.<java.util.Properties: java.util.Set stringPropertyNames()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r28 = virtualinvoke r0.<java.util.Properties: java.lang.String getProperty(java.lang.String)>(r10);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;monitorStmt for local initialized from param;;exitmonitor r23;;pattern detected param  r0 must not be null it define a local r23which used in  monitorStmt 
*;;*;;*;;*;;*;;*;;monitorStmt for local initialized from param;;exitmonitor r23;;pattern detected param  r0 must not be null it define a local r23which used in  monitorStmt 
java.util.PropertyResourceBundle;;handleGetObject;;1;;public java.lang.Object handleGetObject(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;useLocale;;1;;public java.util.Scanner useLocale(java.util.Locale)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.util.Locale: boolean equals(java.lang.Object)>($r4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.Scanner;;hasNext;;1;;public boolean hasNext(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;next;;1;;public java.lang.String next(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;findInLine;;1;;public java.lang.String findInLine(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;findWithinHorizon;;1;;public java.lang.String findWithinHorizon(java.util.regex.Pattern, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Scanner;;skip;;1;;public java.util.Scanner skip(java.util.regex.Pattern)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.Timer;;schedule;;1;;public void schedule(java.util.TimerTask, java.util.Date)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Timer;;schedule;;1;;public void schedule(java.util.TimerTask, java.util.Date, long)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.Timer;;scheduleAtFixedRate;;1;;public void scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r2.<java.util.Date: long getTime()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;<init>;;1;;public void <init>(java.util.SortedMap)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r1.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.SortedMap: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.SortedMap: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = interfaceinvoke r1.<java.util.Map: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r2 = interfaceinvoke $r4.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeMap;;getEntry;;1;;final java.util.TreeMap$Entry getEntry(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r11;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;compare;;1;;final int compare(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i0 = interfaceinvoke $r4.<java.lang.Comparable: int compareTo(java.lang.Object)>(r2);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.TreeMap;;key;;1;;static java.lang.Object key(java.util.TreeMap$Entry)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.TreeMap;;addAllForTreeSet;;1;;void addAllForTreeSet(java.util.SortedSet, java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.SortedSet: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = interfaceinvoke r1.<java.util.SortedSet: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeSet;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.TreeSet;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i1 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r4 = interfaceinvoke r2.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.UnknownFormatFlagsException;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.UUID;;fromString;;1;;public static java.util.UUID fromString(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r1 = virtualinvoke r0.<java.lang.String: java.lang.String[] split(java.lang.String)>("-");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.UUID;;compareTo;;1;;public int compareTo(java.util.UUID)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.UUID: long mostSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l5 = r1.<java.util.UUID: long mostSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l8 = r1.<java.util.UUID: long leastSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l11 = r1.<java.util.UUID: long leastSigBits>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;submit;;1;;public java.util.concurrent.Future submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.AbstractExecutorService;;invokeAny;;1;;public java.lang.Object invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.AbstractExecutorService;;invokeAll;;1;;public java.util.List invokeAll(java.util.Collection) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r9;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.TimeUnit;;timedWait;;1;;public void timedWait(java.lang.Object, long) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: void wait(long,int)>(l1, i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.TimeUnit;;timedJoin;;1;;public void timedJoin(java.lang.Thread, long) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Thread: void join(long,int)>(l1, i2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.FutureTask;;<init>;;1;;public void <init>(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.FutureTask;;get;;1;;public java.lang.Object get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ExecutorCompletionService;;<init>;;1;;public void <init>(java.util.concurrent.Executor)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ExecutorCompletionService;;submit;;1;;public java.util.concurrent.Future submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ExecutorCompletionService;;submit;;1;;public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;acquireQueued;;1;;final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node predecessor()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;isQueued;;1;;public final boolean isQueued(java.lang.Thread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;isOnSyncQueue;;1;;final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedSynchronizer$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;transferForSignal;;1;;final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;fullyRelease;;1;;final int fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;owns;;1;;public final boolean owns(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;hasWaiters;;1;;public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: boolean hasWaiters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;getWaitQueueLength;;1;;public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: int getWaitQueueLength()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedSynchronizer;;getWaitingThreads;;1;;public final java.util.Collection getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject: java.util.Collection getWaitingThreads()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;<init>;;1;;public void <init>(int, boolean, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i3] = $r9;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.ArrayBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>($r8);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ArrayBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>($r8);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;unlink;;1;;void unlink(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: void lazySetPrev(java.util.concurrent.ConcurrentLinkedDeque$Node)>($r21);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: void lazySetNext(java.util.concurrent.ConcurrentLinkedDeque$Node)>($r23);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;succ;;1;;final java.util.concurrent.ConcurrentLinkedDeque$Node succ(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedDeque;;pred;;1;;final java.util.concurrent.ConcurrentLinkedDeque$Node pred(java.util.concurrent.ConcurrentLinkedDeque$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedDeque$Node: java.util.concurrent.ConcurrentLinkedDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;removeFirstOccurrence;;1;;public boolean removeFirstOccurrence(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;removeLastOccurrence;;1;;public boolean removeLastOccurrence(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.Object: boolean equals(java.lang.Object)>(r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedDeque;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;updateHead;;1;;final void updateHead(java.util.concurrent.ConcurrentLinkedQueue$Node, java.util.concurrent.ConcurrentLinkedQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ConcurrentLinkedQueue$Node: void lazySetNext(java.util.concurrent.ConcurrentLinkedQueue$Node)>(r1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;succ;;1;;final java.util.concurrent.ConcurrentLinkedQueue$Node succ(java.util.concurrent.ConcurrentLinkedQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ConcurrentLinkedQueue$Node: java.util.concurrent.ConcurrentLinkedQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ConcurrentLinkedQueue;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentLinkedQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i2] = r3;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.ConcurrentSkipListMap;;compare;;1;;int compare(java.lang.Object, java.lang.Object) throws java.lang.ClassCastException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i1 = interfaceinvoke $r4.<java.lang.Comparable: int compareTo(java.lang.Object)>(r2);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;inHalfOpenRange;;1;;boolean inHalfOpenRange(java.lang.Object, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;inOpenRange;;1;;boolean inOpenRange(java.lang.Object, java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;<init>;;1;;public void <init>(java.util.SortedMap)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = interfaceinvoke r1.<java.util.SortedMap: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;put;;1;;public java.lang.Object put(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;containsValue;;1;;public boolean containsValue(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r11 = interfaceinvoke r2.<java.util.Map: java.lang.Object get(java.lang.Object)>($r10);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r12 = interfaceinvoke r2.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListMap;;putIfAbsent;;1;;public java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;remove;;1;;public boolean remove(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;replace;;1;;public java.lang.Object replace(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;headMap;;1;;public java.util.concurrent.ConcurrentNavigableMap headMap(java.lang.Object, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;tailMap;;1;;public java.util.concurrent.ConcurrentNavigableMap tailMap(java.lang.Object, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ConcurrentSkipListMap;;toList;;1;;static final java.util.List toList(java.util.Collection)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r0.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;<init>;;1;;public void <init>(java.util.SortedSet)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = interfaceinvoke r1.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z2 = interfaceinvoke r2.<java.util.Collection: boolean containsAll(java.util.Collection)>(r0);;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.concurrent.ConcurrentSkipListSet;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.CopyOnWriteArrayList;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;removeAll;;1;;public boolean removeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;retainAll;;1;;public boolean retainAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean contains(java.lang.Object)>(r5);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAllAbsent;;1;;public int addAllAbsent(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAll;;1;;public boolean addAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CopyOnWriteArrayList;;addAll;;1;;public boolean addAll(int, java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CountDownLatch;;await;;1;;public boolean await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.CyclicBarrier;;await;;1;;public int await(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.BrokenBarrierException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.DelayQueue;;poll;;1;;public java.util.concurrent.Delayed poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.DelayQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.DelayQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Exchanger;;exchange;;1;;public java.lang.Object exchange(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.LockSupport;;getBlocker;;1;;public static java.lang.Object getBlocker(java.lang.Thread)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingQueue;;put;;1;;public void put(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;offer;;2;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingQueue;;unlink;;2;;void unlink(java.util.concurrent.LinkedBlockingQueue$Node, java.util.concurrent.LinkedBlockingQueue$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.LinkedBlockingQueue$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.LinkedBlockingQueue$Node: java.util.concurrent.LinkedBlockingQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2.<java.util.concurrent.LinkedBlockingQueue$Node: java.util.concurrent.LinkedBlockingQueue$Node next> = $r3;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i3] = $r10;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i1] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.LinkedBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;unconfigurableExecutorService;;1;;public static java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;unconfigurableScheduledExecutorService;;1;;public static java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.lang.Runnable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.security.PrivilegedAction)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;callable;;1;;public static java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;privilegedCallable;;1;;public static java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.Executors;;privilegedCallableUsingCurrentClassLoader;;1;;public static java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r1;;pattern detected param  r0 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;runWorker;;1;;final void runWorker(java.util.concurrent.ThreadPoolExecutor$Worker)
*;; * ;; * ;;*;;r1;;10
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Runnable firstTask>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Runnable firstTask> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void lock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r9 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks> = $l1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void unlock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l2 = r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.ThreadPoolExecutor$Worker: long completedTasks> = $l3;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ThreadPoolExecutor$Worker: void unlock()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;<init>;;1;;public void <init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l5 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;execute;;1;;public void execute(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;awaitTermination;;1;;public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;setThreadFactory;;1;;public void setThreadFactory(java.util.concurrent.ThreadFactory)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;setRejectedExecutionHandler;;1;;public void setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ThreadPoolExecutor;;setKeepAliveTime;;1;;public void setKeepAliveTime(long, java.util.concurrent.TimeUnit)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ThreadPoolExecutor;;getKeepAliveTime;;1;;public long getKeepAliveTime(java.util.concurrent.TimeUnit)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long convert(long,java.util.concurrent.TimeUnit)>($l0, $r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;put;;1;;public void put(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;offer;;2;;public boolean offer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;containsAll;;1;;public boolean containsAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = interfaceinvoke r1.<java.util.Collection: boolean isEmpty()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.SynchronousQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.SynchronousQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.SynchronousQueue;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.ScheduledThreadPoolExecutor;;reExecutePeriodic;;1;;void reExecutePeriodic(java.util.concurrent.RunnableScheduledFuture)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.concurrent.RunnableScheduledFuture: boolean cancel(boolean)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;work;;1;;final void work(java.util.concurrent.ForkJoinWorkerThread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$z1 = r1.<java.util.concurrent.ForkJoinWorkerThread: boolean terminate>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinPool;;tryAwaitJoin;;1;;final void tryAwaitJoin(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void tryAwaitDone(long)>(0L);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;timedAwaitJoin;;1;;final void timedAwaitJoin(java.util.concurrent.ForkJoinTask, long)
*;; * ;; * ;;*;;r1;;6
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i4 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i8 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void tryAwaitDone(long)>(l2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i10 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: void cancelIgnoringExceptions()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;deregisterWorker;;1;;final void deregisterWorker(java.util.concurrent.ForkJoinWorkerThread, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;i0 = r1.<java.util.concurrent.ForkJoinWorkerThread: int poolIndex>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;i1 = r1.<java.util.concurrent.ForkJoinWorkerThread: int stealCount>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinPool;;<init>;;1;;public void <init>(int, java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory, java.lang.Thread$UncaughtExceptionHandler, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;invoke;;1;;public java.lang.Object invoke(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;execute;;1;;public void execute(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;execute;;1;;public void execute(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.util.concurrent.Callable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.lang.Runnable, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;submit;;1;;public java.util.concurrent.ForkJoinTask submit(java.lang.Runnable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.ForkJoinPool;;invokeAll;;1;;public java.util.List invokeAll(java.util.Collection)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = interfaceinvoke r1.<java.util.Collection: int size()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;drainTasksTo;;1;;protected int drainTasksTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;awaitTermination;;1;;public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinPool;;managedBlock;;1;;public static void managedBlock(java.util.concurrent.ForkJoinPool$ManagedBlocker) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = interfaceinvoke r0.<java.util.concurrent.ForkJoinPool$ManagedBlocker: boolean isReleasable()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = interfaceinvoke r0.<java.util.concurrent.ForkJoinPool$ManagedBlocker: boolean block()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinWorkerThread;;<init>;;1;;protected void <init>(java.util.concurrent.ForkJoinPool)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.ForkJoinPool: java.lang.String nextWorkerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r1.<java.util.concurrent.ForkJoinPool: int registerWorker(java.util.concurrent.ForkJoinWorkerThread)>(r0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$z0 = r1.<java.util.concurrent.ForkJoinPool: boolean locallyFifo>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.ForkJoinPool: java.lang.Thread$UncaughtExceptionHandler ueh>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinWorkerThread;;drainTasksTo;;1;;final int drainTasksTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Collection: boolean add(java.lang.Object)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinWorkerThread;;joinTask;;1;;final int joinTask(java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i2 = r1.<java.util.concurrent.ForkJoinTask: int status>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.ForkJoinTask;;invokeAll;;2;;public static void invokeAll(java.util.concurrent.ForkJoinTask, java.util.concurrent.ForkJoinTask)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.util.concurrent.ForkJoinTask: java.lang.Object invoke()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: java.util.concurrent.ForkJoinTask fork()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.concurrent.ForkJoinTask: java.lang.Object join()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.ForkJoinTask;;invokeAll;;1;;public static transient void invokeAll(java.util.concurrent.ForkJoinTask[])
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r2 = r0[i1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r5 = r0[i4];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.concurrent.ForkJoinTask;;invokeAll;;1;;public static java.util.Collection invokeAll(java.util.Collection)
*;; * ;; * ;;*;;r0;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = interfaceinvoke r0.<java.util.Collection: int size()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = interfaceinvoke r0.<java.util.Collection: java.lang.Object[] toArray(java.lang.Object[])>($r4);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$i3 = interfaceinvoke r1.<java.util.List: int size()>();;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r7 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i1);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r10 = interfaceinvoke r1.<java.util.List: java.lang.Object get(int)>(i5);;pattern detected param  r0 must not be null it define a local r1which used in  InvokeExpr 
java.util.concurrent.ForkJoinTask;;get;;1;;public final java.lang.Object get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l7 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toMillis(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = interfaceinvoke r1.<java.util.Collection: java.util.Iterator iterator()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;unlink;;1;;void unlink(java.util.concurrent.LinkedBlockingDeque$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.util.concurrent.LinkedBlockingDeque$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.util.concurrent.LinkedBlockingDeque$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.LinkedBlockingDeque$Node: java.lang.Object item> = null;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedBlockingDeque;;offerFirst;;1;;public boolean offerFirst(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerLast;;1;;public boolean offerLast(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;putFirst;;1;;public void putFirst(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;putLast;;1;;public void putLast(java.lang.Object) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerFirst;;2;;public boolean offerFirst(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;offerLast;;2;;public boolean offerLast(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;pollFirst;;1;;public java.lang.Object pollFirst(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;pollLast;;1;;public java.lang.Object pollLast(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedBlockingDeque;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedBlockingDeque;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[$i4] = $r9;;pattern detected param  r1 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.LinkedTransferQueue;;succ;;1;;final java.util.concurrent.LinkedTransferQueue$Node succ(java.util.concurrent.LinkedTransferQueue$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;r2 = r1.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedTransferQueue;;unsplice;;1;;final void unsplice(java.util.concurrent.LinkedTransferQueue$Node, java.util.concurrent.LinkedTransferQueue$Node)
*;; * ;; * ;;*;;r2;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<java.util.concurrent.LinkedTransferQueue$Node: void forgetContents()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r3 = r2.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r2 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r8 = r2.<java.util.concurrent.LinkedTransferQueue$Node: java.util.concurrent.LinkedTransferQueue$Node next>;;pattern detected param  r2 must not be null  because used in  FieldRef 
java.util.concurrent.LinkedTransferQueue;;tryTransfer;;1;;public boolean tryTransfer(java.lang.Object, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r2.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedTransferQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.LinkedTransferQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.LinkedTransferQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.Phaser;;awaitAdvanceInterruptibly;;1;;public int awaitAdvanceInterruptibly(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.TimeoutException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;<init>;;1;;public void <init>(java.util.Collection)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r6 = interfaceinvoke r3.<java.util.SortedSet: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r3which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r8 = virtualinvoke r7.<java.util.concurrent.PriorityBlockingQueue: java.util.Comparator comparator()>();;pattern detected param  r1 must not be null it define a local r7which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r9 = virtualinvoke r7.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null it define a local r7which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r10 = interfaceinvoke r1.<java.util.Collection: java.lang.Object[] toArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;offer;;1;;public boolean offer(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r6;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;poll;;1;;public java.lang.Object poll(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.PriorityBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;drainTo;;1;;public int drainTo(java.util.Collection, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.PriorityBlockingQueue;;toArray;;1;;public java.lang.Object[] toArray(java.lang.Object[])
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[i0] = null;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.Semaphore;;tryAcquire;;1;;public boolean tryAcquire(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l1 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.Semaphore;;tryAcquire;;1;;public boolean tryAcquire(int, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r1.<java.util.concurrent.TimeUnit: long toNanos(long)>(l1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicIntegerArray;;<init>;;1;;public void <init>(int[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Object clone()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicLongArray;;<init>;;1;;public void <init>(long[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.lang.Object: java.lang.Object clone()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicMarkableReference;;get;;1;;public java.lang.Object get(boolean[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = $z0;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.atomic.AtomicMarkableReference;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.atomic.AtomicStampedReference;;get;;1;;public java.lang.Object get(int[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;r1[0] = $i0;;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.concurrent.atomic.AtomicStampedReference;;objectFieldOffset;;2;;static long objectFieldOffset(sun.misc.Unsafe, java.lang.String, java.lang.Class)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r0.<sun.misc.Unsafe: long objectFieldOffset(java.lang.reflect.Field)>($r5);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r2.<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>(r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;acquireQueued;;1;;final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node, long)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node predecessor()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;isQueued;;1;;public final boolean isQueued(java.lang.Thread)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;isOnSyncQueue;;1;;final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i0 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node prev>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node next>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;transferForSignal;;1;;final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: java.lang.Thread thread>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;fullyRelease;;1;;final long fullyRelease(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node: int waitStatus> = 1;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;owns;;1;;public final boolean owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;hasWaiters;;1;;public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: boolean hasWaiters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;getWaitQueueLength;;1;;public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: int getWaitQueueLength()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer;;getWaitingThreads;;1;;public final java.util.Collection getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject: java.util.Collection getWaitingThreads()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.concurrent.locks.ReentrantReadWriteLock;;hasWaiters;;1;;public boolean hasWaiters(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantReadWriteLock;;getWaitQueueLength;;1;;public int getWaitQueueLength(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.concurrent.locks.ReentrantReadWriteLock;;getWaitingThreads;;1;;protected java.util.Collection getWaitingThreads(java.util.concurrent.locks.Condition)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.Attributes;;putAll;;1;;public void putAll(java.util.Map)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;write;;1;;void write(java.io.DataOutputStream) throws java.io.IOException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r18);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>("\r\n");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;writeMain;;1;;void writeMain(java.io.DataOutputStream) throws java.io.IOException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r17);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>($r28);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.io.DataOutputStream: void writeBytes(java.lang.String)>("\r\n");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Attributes;;read;;2;;void read(java.util.jar.Manifest$FastInputStream, byte[]) throws java.io.IOException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: int readLine(byte[])>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$b14 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: byte peek()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$b21 = virtualinvoke r1.<java.util.jar.Manifest$FastInputStream: byte peek()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;5
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b4 = r2[i3];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b6 = r2[$i5];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b7 = r2[0];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b17 = r2[$i16];;pattern detected param  r2 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$b19 = r2[i1];;pattern detected param  r2 must not be null  because used in  ArrayRef 
java.util.jar.Manifest;;<init>;;1;;public void <init>(java.util.jar.Manifest)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = virtualinvoke r1.<java.util.jar.Manifest: java.util.Map getEntries()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.Manifest;;make72Safe;;1;;static void make72Safe(java.lang.StringBuffer)
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;i0 = virtualinvoke r0.<java.lang.StringBuffer: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.lang.StringBuffer: java.lang.StringBuffer insert(int,java.lang.String)>(i1, "\r\n ");;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.jar.Manifest;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r4 = virtualinvoke r2.<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r6 = virtualinvoke r2.<java.util.jar.Manifest: java.util.Map getEntries()>();;pattern detected param  r1 must not be null it define a local r2which used in  InvokeExpr 
java.util.jar.JarEntry;;<init>;;1;;public void <init>(java.util.jar.JarEntry)
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.jar.JarEntry: java.util.jar.Attributes attr>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.jar.JarEntry: java.security.cert.Certificate[] certs>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.jar.JarEntry: java.security.CodeSigner[] signers>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.zip.ZipEntry;;<init>;;1;;public void <init>(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.ZipEntry;;<init>;;1;;public void <init>(java.util.zip.ZipEntry)
*;; * ;; * ;;*;;r1;;9
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r2 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l0 = r1.<java.util.zip.ZipEntry: long time>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l2 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l3 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i4 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.zip.ZipEntry: int flag>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r3 = r1.<java.util.zip.ZipEntry: byte[] extra>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r4 = r1.<java.util.zip.ZipEntry: java.lang.String comment>;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.jar.JarFile;;getInputStream;;1;;public synchronized java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r10 = virtualinvoke r1.<java.util.zip.ZipEntry: java.lang.String getName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JarFile;;entryNames;;1;;java.util.Enumeration entryNames(java.security.CodeSource[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r5 = r1[i0];;pattern detected param  r1 must not be null  because used in  ArrayRef 
java.util.zip.ZipFile;;<init>;;2;;public void <init>(java.io.File, int, java.nio.charset.Charset) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r13;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.io.File: java.lang.String getPath()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l5 = virtualinvoke r1.<java.io.File: long lastModified()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipFile;;getEntry;;1;;public java.util.zip.ZipEntry getEntry(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.ZipFile;;getInputStream;;1;;public java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r10;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JarVerifier;;beginEntry;;1;;public void beginEntry(java.util.jar.JarEntry, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r2;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(r4, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void setEntry(java.lang.String,java.util.jar.JarEntry)>(null, r1);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;update;;1;;public void update(int, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<sun.security.util.ManifestEntryVerifier: void update(byte)>($b1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;update;;1;;public void update(int, byte[], int, int, sun.security.util.ManifestEntryVerifier) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r2.<sun.security.util.ManifestEntryVerifier: void update(byte[],int,int)>(r1, i1, i0);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;getCodeSigners;;2;;public java.security.CodeSigner[] getCodeSigners(java.util.jar.JarFile, java.util.jar.JarEntry)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r1.<java.util.jar.JarFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r2.<java.util.jar.JarEntry: java.lang.String getName()>();;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.jar.JarVerifier;;entryNames;;1;;public synchronized java.util.Enumeration entryNames(java.util.jar.JarFile, java.security.CodeSource[])
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r9 = r2[i0];;pattern detected param  r2 must not be null  because used in  ArrayRef 
java.util.jar.JarVerifier;;isSigningRelated;;1;;static boolean isSigningRelated(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.zip.ZipCoder;;getBytes;;1;;byte[] getBytes(java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.lang.String: char[] toCharArray()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.Inflater;;setInput;;1;;public void setInput(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Inflater;;setDictionary;;1;;public void setDictionary(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Inflater;;inflate;;1;;public int inflate(byte[], int, int) throws java.util.zip.DataFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JavaUtilJarAccessImpl;;jarFileHasClassPathAttribute;;1;;public boolean jarFileHasClassPathAttribute(java.util.jar.JarFile) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.util.jar.JarFile: boolean hasClassPathAttribute()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getCodeSources;;1;;public java.security.CodeSource[] getCodeSources(java.util.jar.JarFile, java.net.URL)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.jar.JarFile: java.security.CodeSource[] getCodeSources(java.net.URL)>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getCodeSource;;1;;public java.security.CodeSource getCodeSource(java.util.jar.JarFile, java.net.URL, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.util.jar.JarFile: java.security.CodeSource getCodeSource(java.net.URL,java.lang.String)>(r2, r3);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;entryNames;;1;;public java.util.Enumeration entryNames(java.util.jar.JarFile, java.security.CodeSource[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r1.<java.util.jar.JarFile: java.util.Enumeration entryNames(java.security.CodeSource[])>(r2);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;entries2;;1;;public java.util.Enumeration entries2(java.util.jar.JarFile)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.jar.JarFile: java.util.Enumeration entries2()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;setEagerValidation;;1;;public void setEagerValidation(java.util.jar.JarFile, boolean)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.jar.JarFile: void setEagerValidation(boolean)>(z0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.jar.JavaUtilJarAccessImpl;;getManifestDigests;;1;;public java.util.List getManifestDigests(java.util.jar.JarFile)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r2 = virtualinvoke r1.<java.util.jar.JarFile: java.util.List getManifestDigests()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipInputStream;;<init>;;2;;public void <init>(java.io.InputStream, java.nio.charset.Charset)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r8;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r9;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterInputStream;;read;;1;;public int read(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.CRC32;;update;;1;;public void update(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.jar.JarOutputStream;;<init>;;1;;public void <init>(java.io.OutputStream, java.util.jar.Manifest) throws java.io.IOException
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.jar.JarOutputStream;;putNextEntry;;1;;public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;2
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.zip.ZipEntry: byte[] getExtra()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.zip.ZipEntry: void setExtra(byte[])>(r4);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.zip.ZipOutputStream;;<init>;;1;;public void <init>(java.io.OutputStream, java.nio.charset.Charset)
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.ZipOutputStream;;putNextEntry;;1;;public void putNextEntry(java.util.zip.ZipEntry) throws java.io.IOException
*;; * ;; * ;;*;;r1;;24
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l1 = r1.<java.util.zip.ZipEntry: long time>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.util.zip.ZipEntry: void setTime(long)>($l0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i3 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int method> = $i4;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = 0;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i5 = r1.<java.util.zip.ZipEntry: int method>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l6 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l8 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l10 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = 8;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l12 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l14 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: long size> = $l14;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l15 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l17 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: long csize> = $l17;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l18 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l19 = r1.<java.util.zip.ZipEntry: long csize>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l21 = r1.<java.util.zip.ZipEntry: long size>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$l23 = r1.<java.util.zip.ZipEntry: long crc>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r7 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$r11 = r1.<java.util.zip.ZipEntry: java.lang.String name>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;$i25 = r1.<java.util.zip.ZipEntry: int flag>;;pattern detected param  r1 must not be null  because used in  FieldRef 
*;;*;;*;;*;;*;;*;;FieldRef for param;;r1.<java.util.zip.ZipEntry: int flag> = $i26;;pattern detected param  r1 must not be null  because used in  FieldRef 
java.util.zip.Deflater;;setInput;;1;;public void setInput(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Deflater;;setDictionary;;1;;public void setDictionary(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.Deflater;;deflate;;1;;public int deflate(byte[], int, int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.StreamHandler;;setOutputStream;;1;;protected synchronized void setOutputStream(java.io.OutputStream) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LogRecord;;<init>;;1;;public void <init>(java.util.logging.Level, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LogRecord;;setLevel;;1;;public void setLevel(java.util.logging.Level)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;setFormatter;;1;;public void setFormatter(java.util.logging.Formatter) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Handler;;setErrorManager;;1;;public void setErrorManager(java.util.logging.ErrorManager)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;setLevel;;1;;public synchronized void setLevel(java.util.logging.Level) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Handler;;isLoggable;;1;;public boolean isLoggable(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r4 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LogManager;;addPropertyChangeListener;;1;;public void addPropertyChangeListener(java.beans.PropertyChangeListener) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LogManager;;addLogger;;1;;public synchronized boolean addLogger(java.util.logging.Logger)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.Logger: java.lang.String getName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Formatter;;formatMessage;;1;;public synchronized java.lang.String formatMessage(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;5
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r3 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.ResourceBundle getResourceBundle()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r5 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r7 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Object[] getParameters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Level;;<init>;;1;;protected void <init>(java.lang.String, int, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.Level;;parse;;1;;public static synchronized java.util.logging.Level parse(java.lang.String) throws java.lang.IllegalArgumentException
*;; * ;; * ;;*;;r0;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r0.<java.lang.String: int length()>();;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r0.<java.lang.String: boolean equals(java.lang.Object)>($r6);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r0.<java.lang.String: boolean equals(java.lang.Object)>($r18);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.logging.Level;;equals;;1;;public boolean equals(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;FieldRef for local initialized from param;;$i0 = r2.<java.util.logging.Level: int value>;;pattern detected param  r1 must not be null it define a local r2which used in  FieldRef 
java.util.logging.SimpleFormatter;;format;;1;;public synchronized java.lang.String format(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;10
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l0 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r8 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r13 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r2 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r15 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r18 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r22 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r23 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r6 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;log;;1;;public void log(java.util.logging.Level, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logp;;1;;public void logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;logrb;;1;;public void logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;isLoggable;;1;;public boolean isLoggable(java.util.logging.Level)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.util.logging.Level: int intValue()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;addHandler;;1;;public void addHandler(java.util.logging.Handler) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;virtualinvoke r1.<java.lang.Object: java.lang.Class getClass()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logger;;setParent;;1;;public void setParent(java.util.logging.Logger)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, boolean) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, int, int) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.FileHandler;;<init>;;1;;public void <init>(java.lang.String, int, int, boolean) throws java.io.IOException, java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i2 = virtualinvoke r1.<java.lang.String: int length()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.XMLFormatter;;format;;1;;public java.lang.String format(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;19
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l2 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l3 = virtualinvoke r1.<java.util.logging.LogRecord: long getMillis()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$l4 = virtualinvoke r1.<java.util.logging.LogRecord: long getSequenceNumber()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getLoggerName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r21 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r24 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r26 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceClassName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r28 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r30 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getSourceMethodName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i5 = virtualinvoke r1.<java.util.logging.LogRecord: int getThreadID()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r35 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r39 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.ResourceBundle getResourceBundle()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r40 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r43 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r46 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getResourceBundleName()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r49 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Object[] getParameters()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r50 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.String getMessage()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r57 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r58 = virtualinvoke r1.<java.util.logging.LogRecord: java.lang.Throwable getThrown()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.Logging;;setLoggerLevel;;1;;public void setLoggerLevel(java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.logging.LoggingPermission;;<init>;;1;;public void <init>(java.lang.String, java.lang.String) throws java.lang.IllegalArgumentException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("control");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;getLevel;;1;;public java.lang.Object getLevel(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = virtualinvoke $r2.<java.util.logging.Logger: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;setLevel;;1;;public void setLevel(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r3.<java.util.logging.Logger: void setLevel(java.util.logging.Level)>($r4);;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;isLoggable;;1;;public boolean isLoggable(java.lang.Object, java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z0 = virtualinvoke $r3.<java.util.logging.Logger: boolean isLoggable(java.util.logging.Level)>($r4);;pattern detected param  r1 must not be null it define a local $r3which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public void log(java.lang.Object, java.lang.Object, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r4.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String)>($r5, r3);;pattern detected param  r1 must not be null it define a local $r4which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public void log(java.lang.Object, java.lang.Object, java.lang.String, java.lang.Throwable)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>($r6, r3, r4);;pattern detected param  r1 must not be null it define a local $r5which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;log;;1;;public transient void log(java.lang.Object, java.lang.Object, java.lang.String, java.lang.Object[])
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;virtualinvoke $r5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Object[])>($r6, r3, r4);;pattern detected param  r1 must not be null it define a local $r5which used in  InvokeExpr 
java.util.logging.LoggingProxyImpl;;getLevelName;;1;;public java.lang.String getLevelName(java.lang.Object)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$r3 = virtualinvoke $r2.<java.util.logging.Level: java.lang.String getName()>();;pattern detected param  r1 must not be null it define a local $r2which used in  InvokeExpr 
java.util.logging.MemoryHandler;;publish;;1;;public synchronized void publish(java.util.logging.LogRecord)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r9 = virtualinvoke r1.<java.util.logging.LogRecord: java.util.logging.Level getLevel()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.logging.MemoryHandler;;setPushLevel;;1;;public void setPushLevel(java.util.logging.Level) throws java.lang.SecurityException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r3;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;<init>;;1;;protected void <init>(java.util.prefs.AbstractPreferences, java.lang.String)
*;; * ;; * ;;*;;r2;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r2.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$i0 = virtualinvoke r2.<java.lang.String: int indexOf(int)>(47);;pattern detected param  r2 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r2.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r2 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;get;;1;;public java.lang.String get(java.lang.String, java.lang.String)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r7;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;node;;1;;public java.util.prefs.Preferences node(java.lang.String)
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z1 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("/");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c0 = virtualinvoke r1.<java.lang.String: char charAt(int)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r13 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;nodeExists;;1;;public boolean nodeExists(java.lang.String) throws java.util.prefs.BackingStoreException
*;; * ;; * ;;*;;r1;;4
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z0 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z4 = virtualinvoke r1.<java.lang.String: boolean equals(java.lang.Object)>("/");;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$c0 = virtualinvoke r1.<java.lang.String: char charAt(int)>(0);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r10 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(1);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.AbstractPreferences;;addPreferenceChangeListener;;1;;public void addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.AbstractPreferences;;addNodeChangeListener;;1;;public void addNodeChangeListener(java.util.prefs.NodeChangeListener)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.prefs.Base64;;main;;1;;public static void main(java.lang.String[])
*;; * ;; * ;;*;;r0;;2
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r4 = r0[0];;pattern detected param  r0 must not be null  because used in  ArrayRef 
*;;*;;*;;*;;*;;*;;ArrayRef for param;;$r5 = r0[1];;pattern detected param  r0 must not be null  because used in  ArrayRef 
java.util.prefs.XmlSupport;;export;;1;;static void export(java.io.OutputStream, java.util.prefs.Preferences, boolean) throws java.io.IOException, java.util.prefs.BackingStoreException
*;; * ;; * ;;*;;r1;;3
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;$z1 = virtualinvoke $r8.<java.util.prefs.AbstractPreferences: boolean isRemoved()>();;pattern detected param  r1 must not be null it define a local $r8which used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$z2 = virtualinvoke r1.<java.util.prefs.Preferences: boolean isUserNode()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
*;;*;;*;;*;;*;;*;;InvokeExpr for local initialized from param;;r7 = virtualinvoke r6.<java.util.prefs.Preferences: java.util.prefs.Preferences parent()>();;pattern detected param  r1 must not be null it define a local r6which used in  InvokeExpr 
java.util.prefs.XmlSupport;;exportMap;;1;;static void exportMap(java.io.OutputStream, java.util.Map) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r7 = interfaceinvoke r1.<java.util.Map: java.util.Set entrySet()>();;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.prefs.XmlSupport;;importMap;;1;;static void importMap(java.io.InputStream, java.util.Map) throws java.io.IOException, java.util.prefs.InvalidPreferencesFormatException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;interfaceinvoke r1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>($r18, $r19);;pattern detected param  r1 must not be null  because used in  InvokeExpr 
java.util.regex.UnicodeProp;;forName;;1;;public static java.util.regex.UnicodeProp forName(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;r4 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r1);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.regex.UnicodeProp;;forPOSIXName;;1;;public static java.util.regex.UnicodeProp forPOSIXName(java.lang.String)
*;; * ;; * ;;*;;r0;;1
*;;*;;*;;*;;*;;*;;InvokeExpr for param;;$r3 = virtualinvoke r0.<java.lang.String: java.lang.String toUpperCase(java.util.Locale)>($r2);;pattern detected param  r0 must not be null  because used in  InvokeExpr 
java.util.zip.Adler32;;update;;1;;public void update(byte[], int, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.DeflaterInputStream;;<init>;;2;;public void <init>(java.io.InputStream, java.util.zip.Deflater, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.DeflaterInputStream;;read;;1;;public int read(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterOutputStream;;<init>;;2;;public void <init>(java.io.OutputStream, java.util.zip.Inflater, int)
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r4;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
*;; * ;; * ;;*;;r2;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r5;;pattern detected param  r2 must not be null  otherwise an exception is thrown 
java.util.zip.InflaterOutputStream;;write;;1;;public void write(byte[], int, int) throws java.io.IOException
*;; * ;; * ;;*;;r1;;1
*;;*;;*;;*;;*;;*;;ThrowStmt for param;;throw $r2;;pattern detected param  r1 must not be null  otherwise an exception is thrown 
